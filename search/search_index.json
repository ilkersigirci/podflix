{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This site contains the project documentation for the <code>podflix</code> project.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>The documentation follows the best practice for project documentation as described by Daniele Procida in the Di\u00e1taxis documentation framework and consists of four separate parts:</p> <ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> </ol> <p>Quickly find what you're looking for depending on your use case by looking at the different pages.</p>"},{"location":"#mkdocs","title":"MkDocs","text":"<ul> <li>For full documentation visit mkdocs.org.</li> </ul> <pre><code># Create a new project.\nmkdocs new [dir-name]\n\n# Start the live-reloading docs server.\nmkdocs serve\n\n# Build the documentation site.\nmkdocs build\n\n# Print help message and exit.\nmkdocs -h\n</code></pre>"},{"location":"explanation/","title":"Explanation","text":"<p>This part of the project documentation focuses on an understanding-oriented approach. You'll get a chance to read about the background of the project, as well as reasoning about how it was implemented.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Give context and background on your library</li> <li>Explain why you created it</li> <li>Provide multiple examples and approaches of how     to work with it</li> <li>Help the reader make connections</li> <li>Avoid writing instructions or technical descriptions     here</li> </ul>"},{"location":"how-to-guides/","title":"How to guides","text":"<p>This part of the project documentation focuses on a problem-oriented approach. You'll tackle common tasks that you might have, with the help of the code provided in this project.</p>"},{"location":"reference/","title":"Reference","text":"<p>This part of the project documentation focuses on an information-oriented approach. Use it as a reference for the technical implementation of the <code>podflix</code> project code.</p> <p>podflix package.</p>"},{"location":"reference/#podflix.db","title":"db","text":"<p>A module for managing database connections and operations.</p>"},{"location":"reference/#podflix.db.db_factory","title":"db_factory","text":"<p>SqlAlchemy database interface factory and implementations.</p>"},{"location":"reference/#podflix.db.db_factory.DBInterfaceFactory","title":"DBInterfaceFactory","text":"<p>Singleton factory class for creating database interface instances.</p>"},{"location":"reference/#podflix.db.db_factory.DBInterfaceFactory.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(db_path='db.sqlite')\n</code></pre> <p>Creates and returns appropriate database interface based on environment settings.</p> <p>Returns the same instance on subsequent calls.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>str | Path</code> <p>Path to SQLite database file. Only used for SQLite interface.</p> <code>'db.sqlite'</code> <p>Returns:</p> Name Type Description <code>SqlAlchemyDBInterface</code> <code>SqlAlchemyDBInterface</code> <p>Singleton instance of appropriate database interface.</p> Source code in <code>src/podflix/db/db_factory.py</code> <pre><code>@classmethod\ndef create(cls, db_path: str | Path = \"db.sqlite\") -&gt; SqlAlchemyDBInterface:\n    \"\"\"Creates and returns appropriate database interface based on environment settings.\n\n    Returns the same instance on subsequent calls.\n\n    Args:\n        db_path: Path to SQLite database file. Only used for SQLite interface.\n\n    Returns:\n        SqlAlchemyDBInterface: Singleton instance of appropriate database interface.\n    \"\"\"\n    if cls._db_interface is None:\n        if env_settings.enable_sqlite_data_layer is True:\n            cls._db_interface = SQLiteDBInterface(db_path)\n\n        # NOTE: Implement postgres\n        else:\n            cls._db_interface = PostgresDBInterface()\n\n    return cls._db_interface\n</code></pre>"},{"location":"reference/#podflix.db.db_factory.PostgresDBInterface","title":"PostgresDBInterface","text":"<p>               Bases: <code>SqlAlchemyDBInterface</code></p> <p>PostgreSQL database interface implementation.</p>"},{"location":"reference/#podflix.db.db_factory.PostgresDBInterface.async_connection","title":"async_connection","text":"<pre><code>async_connection()\n</code></pre> <p>Returns the async PostgreSQL connection string.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representing the async PostgreSQL connection URL.</p> Source code in <code>src/podflix/db/db_factory.py</code> <pre><code>def async_connection(self) -&gt; str:\n    \"\"\"Returns the async PostgreSQL connection string.\n\n    Returns:\n        A string representing the async PostgreSQL connection URL.\n    \"\"\"\n    return f\"postgresql+asyncpg://{self.get_connection_path()}\"\n</code></pre>"},{"location":"reference/#podflix.db.db_factory.PostgresDBInterface.get_connection_path","title":"get_connection_path","text":"<pre><code>get_connection_path()\n</code></pre> <p>Returns the PostgreSQL connection path.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string containing the PostgreSQL connection details including user, password, host, port and database.</p> Source code in <code>src/podflix/db/db_factory.py</code> <pre><code>def get_connection_path(self) -&gt; str:\n    \"\"\"Returns the PostgreSQL connection path.\n\n    Returns:\n        A string containing the PostgreSQL connection details including user, password, host, port and database.\n    \"\"\"\n    connection_str = os.getenv(\"DATABASE_URL\", None)\n\n    if connection_str is None:\n        raise ValueError(\"DATABASE_URL environment variable not set\")\n\n    # Remove protocol prefix if present\n    if connection_str.startswith((\"postgresql://\", \"postgres://\")):\n        connection_str = connection_str.split(\"://\", 1)[1]\n\n    return connection_str\n</code></pre>"},{"location":"reference/#podflix.db.db_factory.PostgresDBInterface.sync_connection","title":"sync_connection","text":"<pre><code>sync_connection()\n</code></pre> <p>Returns the sync PostgreSQL connection string.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representing the sync PostgreSQL connection URL.</p> Source code in <code>src/podflix/db/db_factory.py</code> <pre><code>def sync_connection(self) -&gt; str:\n    \"\"\"Returns the sync PostgreSQL connection string.\n\n    Returns:\n        A string representing the sync PostgreSQL connection URL.\n    \"\"\"\n    return f\"postgresql://{self.get_connection_path()}\"\n</code></pre>"},{"location":"reference/#podflix.db.db_factory.SQLiteDBInterface","title":"SQLiteDBInterface","text":"<pre><code>SQLiteDBInterface(db_path='db.sqlite')\n</code></pre> <p>               Bases: <code>SqlAlchemyDBInterface</code></p> <p>SQLite database interface implementation.</p> Source code in <code>src/podflix/db/db_factory.py</code> <pre><code>def __init__(self, db_path: str | Path = \"db.sqlite\"):\n    self.db_path = Path(db_path)\n    self.db_path.parent.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"reference/#podflix.db.db_factory.SQLiteDBInterface.async_connection","title":"async_connection","text":"<pre><code>async_connection()\n</code></pre> <p>Returns the async SQLite connection string.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representing the async SQLite connection URL.</p> Source code in <code>src/podflix/db/db_factory.py</code> <pre><code>def async_connection(self) -&gt; str:\n    \"\"\"Returns the async SQLite connection string.\n\n    Returns:\n        A string representing the async SQLite connection URL.\n    \"\"\"\n    return f\"sqlite+aiosqlite:///{self.get_connection_path()}\"\n</code></pre>"},{"location":"reference/#podflix.db.db_factory.SQLiteDBInterface.get_connection_path","title":"get_connection_path","text":"<pre><code>get_connection_path()\n</code></pre> <p>Returns the SQLite database file path.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representing the path to the SQLite database file.</p> Source code in <code>src/podflix/db/db_factory.py</code> <pre><code>def get_connection_path(self) -&gt; str:\n    \"\"\"Returns the SQLite database file path.\n\n    Returns:\n        A string representing the path to the SQLite database file.\n    \"\"\"\n    return str(self.db_path)\n</code></pre>"},{"location":"reference/#podflix.db.db_factory.SQLiteDBInterface.sync_connection","title":"sync_connection","text":"<pre><code>sync_connection()\n</code></pre> <p>Returns the sync SQLite connection string.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representing the sync SQLite connection URL.</p> Source code in <code>src/podflix/db/db_factory.py</code> <pre><code>def sync_connection(self) -&gt; str:\n    \"\"\"Returns the sync SQLite connection string.\n\n    Returns:\n        A string representing the sync SQLite connection URL.\n    \"\"\"\n    return f\"sqlite:///{self.get_connection_path()}\"\n</code></pre>"},{"location":"reference/#podflix.db.db_factory.SqlAlchemyDBInterface","title":"SqlAlchemyDBInterface","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for database interfaces.</p>"},{"location":"reference/#podflix.db.db_factory.SqlAlchemyDBInterface.async_connection","title":"async_connection  <code>abstractmethod</code>","text":"<pre><code>async_connection()\n</code></pre> <p>Returns the async database connection string.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representing the async database connection URL.</p> Source code in <code>src/podflix/db/db_factory.py</code> <pre><code>@abstractmethod\ndef async_connection(self) -&gt; str:\n    \"\"\"Returns the async database connection string.\n\n    Returns:\n        A string representing the async database connection URL.\n    \"\"\"\n</code></pre>"},{"location":"reference/#podflix.db.db_factory.SqlAlchemyDBInterface.check_db_connection","title":"check_db_connection","text":"<pre><code>check_db_connection()\n</code></pre> <p>Checks if database connection is valid.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If database connection fails, with details about the error.</p> Source code in <code>src/podflix/db/db_factory.py</code> <pre><code>def check_db_connection(self) -&gt; None:\n    \"\"\"Checks if database connection is valid.\n\n    Raises:\n        Exception: If database connection fails, with details about the error.\n    \"\"\"\n    try:\n        engine = create_engine(self.sync_connection())\n        with engine.connect() as conn:\n            conn.execute(\"SELECT 1\")\n    except Exception as e:\n        db_type = self.__class__.__name__.replace(\"DBInterface\", \"\")\n        raise Exception(f\"{db_type} connection error:\\n{e}\") from e\n</code></pre>"},{"location":"reference/#podflix.db.db_factory.SqlAlchemyDBInterface.get_connection_path","title":"get_connection_path  <code>abstractmethod</code>","text":"<pre><code>get_connection_path()\n</code></pre> <p>Returns the database connection path.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representing the database connection path.</p> Source code in <code>src/podflix/db/db_factory.py</code> <pre><code>@abstractmethod\ndef get_connection_path(self) -&gt; str:\n    \"\"\"Returns the database connection path.\n\n    Returns:\n        A string representing the database connection path.\n    \"\"\"\n</code></pre>"},{"location":"reference/#podflix.db.db_factory.SqlAlchemyDBInterface.sync_connection","title":"sync_connection  <code>abstractmethod</code>","text":"<pre><code>sync_connection()\n</code></pre> <p>Returns the sync database connection string.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representing the sync database connection URL.</p> Source code in <code>src/podflix/db/db_factory.py</code> <pre><code>@abstractmethod\ndef sync_connection(self) -&gt; str:\n    \"\"\"Returns the sync database connection string.\n\n    Returns:\n        A string representing the sync database connection URL.\n    \"\"\"\n</code></pre>"},{"location":"reference/#podflix.db.db_manager","title":"db_manager","text":"<p>Base database management functionality.</p> <p>This module provides database management capabilities including initialization, connection handling, and SQL file execution with retry logic.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from podflix.db.db_manager import DatabaseManager\n&gt;&gt;&gt; db_manager = DatabaseManager()\n&gt;&gt;&gt; db_manager.execute_sql_file(Path(\"init.sql\"), True, \"Initialize\")\n</code></pre> <p>The module contains the following class:</p> <ul> <li><code>DatabaseManager</code> - Handles database operations with retry logic.</li> </ul>"},{"location":"reference/#podflix.db.db_manager.DatabaseManager","title":"DatabaseManager","text":"<pre><code>DatabaseManager(max_retries=5, retry_delay=2)\n</code></pre> <p>Manages database operations with retry logic and error handling.</p> <p>This class provides functionality to manage database operations including reading SQL files, checking table existence, and executing SQL statements with retry logic.</p> <p>Parameters:</p> Name Type Description Default <code>max_retries</code> <code>int</code> <p>Maximum number of connection retry attempts. Defaults to 5.</p> <code>5</code> <code>retry_delay</code> <code>int</code> <p>Initial delay between retries in seconds. Defaults to 2.</p> <code>2</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; db_manager = DatabaseManager(max_retries=3, retry_delay=1)\n&gt;&gt;&gt; db_manager.execute_sql_file(Path(\"init.sql\"), True, \"Initialize\")\n</code></pre> Source code in <code>src/podflix/db/db_manager.py</code> <pre><code>def __init__(self, max_retries: int = 5, retry_delay: int = 2):\n    self.max_retries = max_retries\n    self.retry_delay = retry_delay\n    self.engine = sa.create_engine(DBInterfaceFactory.create().sync_connection())\n</code></pre>"},{"location":"reference/#podflix.db.db_manager.DatabaseManager.execute_sql_file","title":"execute_sql_file","text":"<pre><code>execute_sql_file(sql_file, check_exists, operation_name)\n</code></pre> <p>Execute SQL statements from a file with retry logic.</p> <p>Parameters:</p> Name Type Description Default <code>sql_file</code> <code>Path</code> <p>Path to the SQL file to execute.</p> required <code>check_exists</code> <code>bool</code> <p>If True, checks for existing tables before execution.</p> required <code>operation_name</code> <code>str</code> <p>Name of the operation for logging purposes.</p> required <p>Raises:</p> Type Description <code>OperationalError</code> <p>If database connection fails after max retries.</p> <code>Exception</code> <p>If SQL statement execution fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; db_manager = DatabaseManager()\n&gt;&gt;&gt; db_manager.execute_sql_file(\n...     Path(\"init.sql\"),\n...     check_exists=True,\n...     operation_name=\"Initialize\"\n... )\n</code></pre> Source code in <code>src/podflix/db/db_manager.py</code> <pre><code>@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=2, min=2, max=30),\n    retry=retry_if_exception_type(OperationalError),\n    before_sleep=lambda retry_state: logger.warning(\n        f\"Database connection attempt {retry_state.attempt_number} failed, retrying...\"\n    ),\n)\ndef execute_sql_file(self, sql_file: Path, check_exists: bool, operation_name: str):\n    \"\"\"Execute SQL statements from a file with retry logic.\n\n    Args:\n        sql_file: Path to the SQL file to execute.\n        check_exists: If True, checks for existing tables before execution.\n        operation_name: Name of the operation for logging purposes.\n\n    Raises:\n        OperationalError: If database connection fails after max retries.\n        Exception: If SQL statement execution fails.\n\n    Examples:\n        &gt;&gt;&gt; db_manager = DatabaseManager()\n        &gt;&gt;&gt; db_manager.execute_sql_file(\n        ...     Path(\"init.sql\"),\n        ...     check_exists=True,\n        ...     operation_name=\"Initialize\"\n        ... )\n    \"\"\"\n    with self.engine.connect() as conn:\n        exists = self.table_exists(conn)\n        if check_exists and exists:\n            logger.info(\"Database already initialized, skipping...\")\n            return\n\n        if not check_exists and not exists:\n            logger.info(\"No tables found in database, nothing to drop...\")\n            return\n\n        logger.info(f\"{operation_name} database...\")\n        raw_sql_statements = self.read_sql_file(sql_file)\n\n        for stmt in raw_sql_statements:\n            try:\n                conn.execute(sa.text(stmt))\n            except Exception as e:\n                logger.error(f\"Error executing statement: {e}\")\n                raise\n\n        conn.commit()\n        logger.info(f\"Database {operation_name.lower()} completed successfully\")\n</code></pre>"},{"location":"reference/#podflix.db.db_manager.DatabaseManager.read_sql_file","title":"read_sql_file","text":"<pre><code>read_sql_file(file_path)\n</code></pre> <p>Read and parse SQL statements from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | Path</code> <p>Path to the SQL file to be read.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of SQL statements parsed from the file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; db_manager = DatabaseManager()\n&gt;&gt;&gt; statements = db_manager.read_sql_file(\"init.sql\")\n&gt;&gt;&gt; len(statements) &gt; 0\nTrue\n</code></pre> Source code in <code>src/podflix/db/db_manager.py</code> <pre><code>def read_sql_file(self, file_path: str | Path) -&gt; list[str]:\n    \"\"\"Read and parse SQL statements from a file.\n\n    Args:\n        file_path: Path to the SQL file to be read.\n\n    Returns:\n        A list of SQL statements parsed from the file.\n\n    Examples:\n        &gt;&gt;&gt; db_manager = DatabaseManager()\n        &gt;&gt;&gt; statements = db_manager.read_sql_file(\"init.sql\")\n        &gt;&gt;&gt; len(statements) &gt; 0\n        True\n    \"\"\"\n    with Path(file_path).open(\"r\") as f:\n        return [x.strip() for x in f.read().split(\";\") if x.strip()]\n</code></pre>"},{"location":"reference/#podflix.db.db_manager.DatabaseManager.table_exists","title":"table_exists","text":"<pre><code>table_exists(conn)\n</code></pre> <p>Check if users table exists in the database.</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <p>SQLAlchemy connection object to use for the query.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the users table exists, False otherwise.</p> <p>Raises:</p> Type Description <code>OperationalError</code> <p>If there's a problem connecting to the database.</p> <code>ProgrammingError</code> <p>If there's a problem executing the SQL query.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; db_manager = DatabaseManager()\n&gt;&gt;&gt; with db_manager.engine.connect() as conn:\n...     exists = db_manager.table_exists(conn)\n&gt;&gt;&gt; isinstance(exists, bool)\nTrue\n</code></pre> Source code in <code>src/podflix/db/db_manager.py</code> <pre><code>def table_exists(self, conn) -&gt; bool:\n    \"\"\"Check if users table exists in the database.\n\n    Args:\n        conn: SQLAlchemy connection object to use for the query.\n\n    Returns:\n        True if the users table exists, False otherwise.\n\n    Raises:\n        OperationalError: If there's a problem connecting to the database.\n        ProgrammingError: If there's a problem executing the SQL query.\n\n    Examples:\n        &gt;&gt;&gt; db_manager = DatabaseManager()\n        &gt;&gt;&gt; with db_manager.engine.connect() as conn:\n        ...     exists = db_manager.table_exists(conn)\n        &gt;&gt;&gt; isinstance(exists, bool)\n        True\n    \"\"\"\n    try:\n        if env_settings.enable_sqlite_data_layer is True:\n            query = \"\"\"\n                SELECT COUNT(*)\n                FROM sqlite_master\n                WHERE type='table' AND name='users'\n            \"\"\"\n        else:  # postgresql\n            query = \"\"\"\n                SELECT EXISTS (\n                    SELECT FROM information_schema.tables\n                    WHERE table_schema = 'public'\n                    AND table_name = 'User'\n                );\n            \"\"\"\n        result = conn.execute(sa.text(query)).scalar()\n        return bool(result)\n    except (OperationalError, ProgrammingError) as e:\n        logger.error(f\"Error checking for tables: {e}\")\n        return False\n</code></pre>"},{"location":"reference/#podflix.db.init_db","title":"init_db","text":"<p>Initialize the database schema using SQL statements from init_db.sql file.</p>"},{"location":"reference/#podflix.db.init_db.initialize_db","title":"initialize_db","text":"<pre><code>initialize_db(max_retries=5, retry_delay=2)\n</code></pre> <p>Initialize the database using SQL statements from init_db.sql file.</p> Source code in <code>src/podflix/db/init_db.py</code> <pre><code>def initialize_db(max_retries: int = 5, retry_delay: int = 2):\n    \"\"\"Initialize the database using SQL statements from init_db.sql file.\"\"\"\n    db_manager = DatabaseManager(max_retries, retry_delay)\n    db_manager.execute_sql_file(\n        Path(__file__).parent / \"init_db.sql\",\n        check_exists=True,\n        operation_name=\"Initializing\",\n    )\n</code></pre>"},{"location":"reference/#podflix.env_settings","title":"env_settings","text":"<p>Application configuration for environment variables.</p>"},{"location":"reference/#podflix.env_settings.EnvSettings","title":"EnvSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>This class is used to load environment variables.</p> <p>They are either from environment or from a .env file and store them as class attributes.</p> Note <ul> <li>environment variables will always take priority over values loaded from a dotenv file</li> <li>environment variable names are case-insensitive</li> <li>environment variable type is inferred from the type hint of the class attribute</li> <li>For environment variables that are not set, a default value should be provided</li> </ul> <p>For more info, see the related pydantic docs: https://docs.pydantic.dev/latest/concepts/pydantic_settings</p>"},{"location":"reference/#podflix.env_settings.EnvSettings.validate_model_api_base","title":"validate_model_api_base","text":"<pre><code>validate_model_api_base(value, values)\n</code></pre> <p>Validate the model API base URL.</p> Source code in <code>src/podflix/env_settings.py</code> <pre><code>@field_validator(\"model_api_base\")\ndef validate_model_api_base(cls, value, values):\n    \"\"\"Validate the model API base URL.\"\"\"\n    if values.data.get(\"enable_openai_api\") is True:\n        logger.debug(\"When OpenAI API is enabled, `model_api_base` environment is ignored and set to OpenAI API.\")\n\n        return \"https://api.openai.com\"\n\n    return value\n</code></pre>"},{"location":"reference/#podflix.env_settings.EnvSettings.validate_openai_key","title":"validate_openai_key","text":"<pre><code>validate_openai_key(value, values)\n</code></pre> <p>Validate the OpenAI API key.</p> Source code in <code>src/podflix/env_settings.py</code> <pre><code>@field_validator(\"openai_api_key\")\ndef validate_openai_key(cls, value, values):\n    \"\"\"Validate the OpenAI API key.\"\"\"\n    if values.data.get(\"enable_openai_api\") is True and value is None:\n        message = \"OpenAI API key should be set, when enable_openai_api is True.\"\n        logger.error(message)\n        raise ValueError(message)\n\n    return value\n</code></pre>"},{"location":"reference/#podflix.env_settings.allowed_values","title":"allowed_values","text":"<pre><code>allowed_values(v, values)\n</code></pre> <p>Validate if a value is in a set of allowed values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; allowed_values(\"a\", [\"a\", \"b\"])\n'a'\n&gt;&gt;&gt; allowed_values(1, [1, 2, 3])\n1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>v</code> <p>The value to validate</p> required <code>values</code> <p>A collection of allowed values</p> required <p>Returns:</p> Type Description <p>The validated value if it exists in the allowed values</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the value is not in the allowed values</p> Source code in <code>src/podflix/env_settings.py</code> <pre><code>def allowed_values(v, values):\n    \"\"\"Validate if a value is in a set of allowed values.\n\n    Examples:\n        &gt;&gt;&gt; allowed_values(\"a\", [\"a\", \"b\"])\n        'a'\n        &gt;&gt;&gt; allowed_values(1, [1, 2, 3])\n        1\n\n    Args:\n        v: The value to validate\n        values: A collection of allowed values\n\n    Returns:\n        The validated value if it exists in the allowed values\n\n    Raises:\n        AssertionError: If the value is not in the allowed values\n    \"\"\"\n    assert v in values\n    return v\n</code></pre>"},{"location":"reference/#podflix.graph","title":"graph","text":"<p>Module about LLM interaction using Langchain Langgprah nodes.</p>"},{"location":"reference/#podflix.graph.mock","title":"mock","text":"<p>Define the mock graph for the Podflix agent.</p>"},{"location":"reference/#podflix.graph.mock.AgentState","title":"AgentState","text":"<p>               Bases: <code>TypedDict</code></p> <p>A dictionary representing the state of the agent.</p>"},{"location":"reference/#podflix.graph.mock.mock_answer","title":"mock_answer  <code>async</code>","text":"<pre><code>mock_answer(state)\n</code></pre> <p>Generate a mock response using a random choice from predefined messages.</p> <p>The function simulates an AI model's response by randomly selecting from a predefined list of messages and returning it as an AIMessage.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; state = {\"messages\": [HumanMessage(content=\"Hello\")]}\n&gt;&gt;&gt; response = await mock_answer(state)\n&gt;&gt;&gt; isinstance(response[\"messages\"][0], AIMessage)\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>AgentState</code> <p>A dictionary containing the current conversation state, including: - messages: A sequence of BaseMessage objects representing the conversation history.</p> required <p>Returns:</p> Type Description <p>A dictionary containing: - messages: A list with a single AIMessage containing the random response.</p> Source code in <code>src/podflix/graph/mock.py</code> <pre><code>async def mock_answer(state: AgentState):\n    \"\"\"Generate a mock response using a random choice from predefined messages.\n\n    The function simulates an AI model's response by randomly selecting from a\n    predefined list of messages and returning it as an AIMessage.\n\n    Examples:\n        &gt;&gt;&gt; state = {\"messages\": [HumanMessage(content=\"Hello\")]}\n        &gt;&gt;&gt; response = await mock_answer(state)\n        &gt;&gt;&gt; isinstance(response[\"messages\"][0], AIMessage)\n        True\n\n    Args:\n        state: A dictionary containing the current conversation state, including:\n            - messages: A sequence of BaseMessage objects representing the conversation history.\n\n    Returns:\n        A dictionary containing:\n            - messages: A list with a single AIMessage containing the random response.\n    \"\"\"\n    # NOTE: Hacky way to get the langfuse trace_id\n    # callback_manager = config.get(\"callbacks\")\n    # for cb in callback_manager.handlers:\n    #     if cb.__class__.__name__.endswith(\"CallbackHandler\"):\n    #         first_run = next(iter(cb.runs.values()))\n    #         first_run_trace_id = first_run.trace_id\n\n    #         print(f\"******** Trace ID ***********: {first_run_trace_id}\")\n\n    random_response = random.choice(MOCK_RESPONSES)\n\n    model = get_mock_model(message=random_response)\n    _ = await model.ainvoke(\"mock\")\n\n    return {\"messages\": [AIMessage(random_response)]}\n</code></pre>"},{"location":"reference/#podflix.graph.podcast_rag","title":"podcast_rag","text":"<p>Define the RAG-based graph for the Podflix agent.</p>"},{"location":"reference/#podflix.graph.podcast_rag.AgentState","title":"AgentState","text":"<p>               Bases: <code>TypedDict</code></p> <p>A dictionary representing the state of the agent.</p>"},{"location":"reference/#podflix.graph.podcast_rag.generate","title":"generate  <code>async</code>","text":"<pre><code>generate(state)\n</code></pre> <p>Generate a response using the retrieved context.</p> Source code in <code>src/podflix/graph/podcast_rag.py</code> <pre><code>async def generate(state: AgentState) -&gt; AgentState:\n    \"\"\"Generate a response using the retrieved context.\"\"\"\n    question = state[\"messages\"][-1].content\n    context = state[\"context\"]\n\n    prompt = ChatPromptTemplate.from_messages(\n        [\n            (\"system\", \"Use the following context to answer the question: {context}\"),\n            (\"human\", \"{question}\"),\n        ]\n    )\n\n    model = get_chat_model()\n    chain = prompt | model | StrOutputParser()\n\n    response = await chain.ainvoke({\"context\": context, \"question\": question})\n\n    return {\n        \"messages\": [AIMessage(content=response)],\n    }\n</code></pre>"},{"location":"reference/#podflix.graph.podcast_rag.retrieve","title":"retrieve  <code>async</code>","text":"<pre><code>retrieve(state)\n</code></pre> <p>Retrieve relevant context based on the user's question.</p> Source code in <code>src/podflix/graph/podcast_rag.py</code> <pre><code>async def retrieve(state: AgentState) -&gt; AgentState:\n    \"\"\"Retrieve relevant context based on the user's question.\"\"\"\n    # TODO: Implement actual retrieval logic\n    # This is a placeholder that should be replaced with your vector store retrieval\n    # question = state[\"messages\"][-1].content\n    # context = f\"Retrieved context for: {question}\"\n    # return {\"messages\": state[\"messages\"]}\n    return {}\n</code></pre>"},{"location":"reference/#podflix.gui","title":"gui","text":"<p>Chainlit UI module.</p>"},{"location":"reference/#podflix.gui.base_chat","title":"base_chat","text":""},{"location":"reference/#podflix.gui.base_chat.settings_update","title":"settings_update  <code>async</code>","text":"<pre><code>settings_update(settings)\n</code></pre> <p>Update settings when changed in UI</p> Source code in <code>src/podflix/gui/base_chat.py</code> <pre><code>@cl.on_settings_update\nasync def settings_update(settings: cl.ChatSettings) -&gt; None:\n    \"\"\"Update settings when changed in UI\"\"\"\n    cl.user_session.set(\"settings\", OpenAIChatGenerationSettings(**settings))\n</code></pre>"},{"location":"reference/#podflix.placeholder","title":"placeholder","text":"<p>Placeholder file to provide several sample math calculations.</p> <p>This module allows the user to make mathematical calculations. Adapted from: https://realpython.com/python-project-documentation-with-mkdocs/</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from podflix import placeholder\n&gt;&gt;&gt; placeholder.add(2, 4)\n6.0\n&gt;&gt;&gt; placeholder.multiply(2.0, 4.0)\n8.0\n&gt;&gt;&gt; from podflix.placeholder import divide\n&gt;&gt;&gt; divide(4.0, 2)\n2.0\n</code></pre> <p>The module contains the following functions:</p> <ul> <li><code>add(a, b)</code> - Returns the sum of two numbers.</li> <li><code>subtract(a, b)</code> - Returns the difference of two numbers.</li> <li><code>multiply(a, b)</code> - Returns the product of two numbers.</li> <li><code>divide(a, b)</code> - Returns the quotient of two numbers.</li> </ul>"},{"location":"reference/#podflix.placeholder.add","title":"add","text":"<pre><code>add(a, b)\n</code></pre> <p>Compute and return the sum of two numbers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; add(4.0, 2.0)\n6.0\n&gt;&gt;&gt; add(4, 2)\n6.0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float | int</code> <p>A number representing the first addend in the addition.</p> required <code>b</code> <code>float | int</code> <p>A number representing the second addend in the addition.</p> required <p>Returns:</p> Type Description <code>float</code> <p>A number representing the arithmetic sum result of <code>a</code> and <code>b</code>.</p> Source code in <code>src/podflix/placeholder.py</code> <pre><code>def add(a: float | int, b: float | int) -&gt; float:\n    \"\"\"Compute and return the sum of two numbers.\n\n    Examples:\n        &gt;&gt;&gt; add(4.0, 2.0)\n        6.0\n        &gt;&gt;&gt; add(4, 2)\n        6.0\n\n    Args:\n        a: A number representing the first addend in the addition.\n        b: A number representing the second addend in the addition.\n\n    Returns:\n        A number representing the arithmetic sum result of `a` and `b`.\n    \"\"\"\n    return float(a + b)\n</code></pre>"},{"location":"reference/#podflix.placeholder.divide","title":"divide","text":"<pre><code>divide(a, b)\n</code></pre> <p>Compute and return the division of two numbers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; divide(4.0, 2.0)\n2.0\n&gt;&gt;&gt; divide(4, 2)\n2.0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float | int</code> <p>A number representing the first divider in the divide.</p> required <code>b</code> <code>float | int</code> <p>A number representing the second divider in the divide.</p> required <p>Returns:</p> Type Description <code>float</code> <p>A number representing the division result of <code>a</code> and <code>b</code>.</p> <p>Raises:</p> Type Description <code>ZeroDivisionError</code> <p>If <code>b</code> is zero.</p> Source code in <code>src/podflix/placeholder.py</code> <pre><code>def divide(a: float | int, b: float | int) -&gt; float:\n    \"\"\"Compute and return the division of two numbers.\n\n    Examples:\n        &gt;&gt;&gt; divide(4.0, 2.0)\n        2.0\n        &gt;&gt;&gt; divide(4, 2)\n        2.0\n\n    Args:\n        a: A number representing the first divider in the divide.\n        b: A number representing the second divider in the divide.\n\n    Returns:\n        A number representing the division result of `a` and `b`.\n\n    Raises:\n        ZeroDivisionError: If `b` is zero.\n    \"\"\"\n    if b == 0:\n        raise ZeroDivisionError(\"division by zero\")\n\n    return float(a / b)\n</code></pre>"},{"location":"reference/#podflix.placeholder.multiply","title":"multiply","text":"<pre><code>multiply(a, b)\n</code></pre> <p>Compute and return the multiplication of two numbers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; multiply(4.0, 2.0)\n8.0\n&gt;&gt;&gt; multiply(4, 2)\n8.0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float | int</code> <p>A number representing the first multiplicator in the multiply.</p> required <code>b</code> <code>float | int</code> <p>A number representing the second multiplicator in the multiply.</p> required <p>Returns:</p> Type Description <code>float</code> <p>A number representing the multiplied result of <code>a</code> and <code>b</code>.</p> Source code in <code>src/podflix/placeholder.py</code> <pre><code>def multiply(a: float | int, b: float | int) -&gt; float:\n    \"\"\"Compute and return the multiplication of two numbers.\n\n    Examples:\n        &gt;&gt;&gt; multiply(4.0, 2.0)\n        8.0\n        &gt;&gt;&gt; multiply(4, 2)\n        8.0\n\n    Args:\n        a: A number representing the first multiplicator in the multiply.\n        b: A number representing the second multiplicator in the multiply.\n\n    Returns:\n        A number representing the multiplied result of `a` and `b`.\n    \"\"\"\n    return float(a * b)\n</code></pre>"},{"location":"reference/#podflix.placeholder.subtract","title":"subtract","text":"<pre><code>subtract(a, b)\n</code></pre> <p>Compute and return the substaction of two numbers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; subtract(4.0, 2.0)\n2.0\n&gt;&gt;&gt; subtract(4, 2)\n2.0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float | int</code> <p>A number representing the first substracter in the substract.</p> required <code>b</code> <code>float | int</code> <p>A number representing the second substracter in the substract.</p> required <p>Returns:</p> Type Description <code>float</code> <p>A number representing the substract result of <code>a</code> and <code>b</code>.</p> Source code in <code>src/podflix/placeholder.py</code> <pre><code>def subtract(a: float | int, b: float | int) -&gt; float:\n    \"\"\"Compute and return the substaction of two numbers.\n\n    Examples:\n        &gt;&gt;&gt; subtract(4.0, 2.0)\n        2.0\n        &gt;&gt;&gt; subtract(4, 2)\n        2.0\n\n    Args:\n        a: A number representing the first substracter in the substract.\n        b:  A number representing the second substracter in the substract.\n\n    Returns:\n        A number representing the substract result of `a` and `b`.\n    \"\"\"\n    return float(a - b)\n</code></pre>"},{"location":"reference/#podflix.utils","title":"utils","text":"<p>Utility functions.</p>"},{"location":"reference/#podflix.utils.chainlit_utils","title":"chainlit_utils","text":"<p>Utility functions.</p>"},{"location":"reference/#podflix.utils.chainlit_utils.data_layer","title":"data_layer","text":"<p>Utility functions for working with ChainLit data layer.</p> <p>This module provides utility functions for configuring and working with ChainLit's data layer, including S3 storage integration and SQLAlchemy database connections.</p>"},{"location":"reference/#podflix.utils.chainlit_utils.data_layer.apply_sqlite_data_layer_fixes","title":"apply_sqlite_data_layer_fixes","text":"<pre><code>apply_sqlite_data_layer_fixes()\n</code></pre> <p>Apply necessary fixes for SQLite data layer configuration.</p> <p>This function applies patches and configurations specific to SQLite data layer when it is enabled in the environment settings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; apply_sqlite_data_layer_fixes()  # Applies fixes if SQLite is enabled\n</code></pre> <p>Returns:</p> Type Description <p>None</p> Source code in <code>src/podflix/utils/chainlit_utils/data_layer.py</code> <pre><code>def apply_sqlite_data_layer_fixes():\n    \"\"\"Apply necessary fixes for SQLite data layer configuration.\n\n    This function applies patches and configurations specific to SQLite data layer\n    when it is enabled in the environment settings.\n\n    Examples:\n        &gt;&gt;&gt; apply_sqlite_data_layer_fixes()  # Applies fixes if SQLite is enabled\n\n    Returns:\n        None\n    \"\"\"\n    if env_settings.enable_sqlite_data_layer is False:\n        return\n\n    from podflix.utils.chainlit_utils.patch_chainlit import custom_resume_thread\n\n    chainlit.socket.resume_thread = custom_resume_thread\n\n    @cl.data_layer\n    def data_layer():\n        return get_custom_sqlalchemy_data_layer(show_logger=True)\n</code></pre>"},{"location":"reference/#podflix.utils.chainlit_utils.data_layer.check_s3_credentials","title":"check_s3_credentials","text":"<pre><code>check_s3_credentials(boto_client)\n</code></pre> <p>Check if the AWS S3 credentials are valid by attempting to list buckets.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; s3_client = get_s3_storage_client()\n&gt;&gt;&gt; check_s3_credentials(s3_client.client)  # No error if credentials are valid\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>boto_client</code> <code>client</code> <p>A boto3 client instance configured for AWS S3.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If connection to AWS S3 fails using provided credentials.</p> Source code in <code>src/podflix/utils/chainlit_utils/data_layer.py</code> <pre><code>def check_s3_credentials(boto_client: boto3.client) -&gt; None:\n    \"\"\"Check if the AWS S3 credentials are valid by attempting to list buckets.\n\n    Examples:\n        &gt;&gt;&gt; s3_client = get_s3_storage_client()\n        &gt;&gt;&gt; check_s3_credentials(s3_client.client)  # No error if credentials are valid\n\n    Args:\n        boto_client: A boto3 client instance configured for AWS S3.\n\n    Returns:\n        None\n\n    Raises:\n        Exception: If connection to AWS S3 fails using provided credentials.\n    \"\"\"\n    try:\n        boto_client.list_buckets()\n        logger.debug(\"AWS S3 Auth Check Passed\")\n    except Exception as e:\n        logger.error(f\"AWS S3 Auth Check Error: {e}\")\n        raise e\n</code></pre>"},{"location":"reference/#podflix.utils.chainlit_utils.data_layer.get_custom_sqlalchemy_data_layer","title":"get_custom_sqlalchemy_data_layer","text":"<pre><code>get_custom_sqlalchemy_data_layer(show_logger=False, enable_s3_storage_provider=False)\n</code></pre> <p>Create and configure a custom SQLAlchemy data layer instance.</p> <p>This function sets up a SQLAlchemy data layer with optional S3 storage integration and logging capabilities.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data_layer = get_custom_sqlalchemy_data_layer()\n&gt;&gt;&gt; isinstance(data_layer, SQLAlchemyDataLayer)\nTrue\n&gt;&gt;&gt; data_layer_with_s3 = get_custom_sqlalchemy_data_layer(enable_s3_storage_provider=True)\n&gt;&gt;&gt; data_layer_with_logging = get_custom_sqlalchemy_data_layer(show_logger=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>show_logger</code> <code>bool</code> <p>Whether to enable SQL query logging. Defaults to False.</p> <code>False</code> <code>enable_s3_storage_provider</code> <code>bool</code> <p>Whether to enable S3 storage integration. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SQLAlchemyDataLayer</code> <code>SQLAlchemyDataLayer</code> <p>A configured data layer instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If S3 storage is enabled but credentials are invalid.</p> Source code in <code>src/podflix/utils/chainlit_utils/data_layer.py</code> <pre><code>def get_custom_sqlalchemy_data_layer(\n    show_logger: bool = False, enable_s3_storage_provider: bool = False\n) -&gt; SQLAlchemyDataLayer:\n    \"\"\"Create and configure a custom SQLAlchemy data layer instance.\n\n    This function sets up a SQLAlchemy data layer with optional S3 storage integration\n    and logging capabilities.\n\n    Examples:\n        &gt;&gt;&gt; data_layer = get_custom_sqlalchemy_data_layer()\n        &gt;&gt;&gt; isinstance(data_layer, SQLAlchemyDataLayer)\n        True\n        &gt;&gt;&gt; data_layer_with_s3 = get_custom_sqlalchemy_data_layer(enable_s3_storage_provider=True)\n        &gt;&gt;&gt; data_layer_with_logging = get_custom_sqlalchemy_data_layer(show_logger=True)\n\n    Args:\n        show_logger: Whether to enable SQL query logging. Defaults to False.\n        enable_s3_storage_provider: Whether to enable S3 storage integration. Defaults to False.\n\n    Returns:\n        SQLAlchemyDataLayer: A configured data layer instance.\n\n    Raises:\n        ValueError: If S3 storage is enabled but credentials are invalid.\n    \"\"\"\n    if enable_s3_storage_provider is True:\n        storage_client = get_s3_storage_client()\n\n        check_s3_credentials(boto_client=storage_client.client)\n    else:\n        storage_client = None\n\n    return SQLAlchemyDataLayer(\n        DBInterfaceFactory.create().async_connection(),\n        ssl_require=False,\n        show_logger=show_logger,\n        storage_provider=storage_client,\n    )\n</code></pre>"},{"location":"reference/#podflix.utils.chainlit_utils.data_layer.get_element_url","title":"get_element_url  <code>async</code>","text":"<pre><code>get_element_url(data_layer, thread_id, element_id)\n</code></pre> <p>Retrieve the URL for accessing an element's file content.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data_layer = get_custom_sqlalchemy_data_layer()\n&gt;&gt;&gt; url = await get_element_url(data_layer, \"thread123\", \"element456\")\n&gt;&gt;&gt; print(url)  # None if not found, URL string if exists\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data_layer</code> <code>SQLAlchemyDataLayer</code> <p>The SQLAlchemy data layer instance to use for retrieval.</p> required <code>thread_id</code> <code>str</code> <p>The unique identifier of the thread containing the element.</p> required <code>element_id</code> <code>str</code> <p>The unique identifier of the element to retrieve.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The URL string if the element exists, None otherwise.</p> Source code in <code>src/podflix/utils/chainlit_utils/data_layer.py</code> <pre><code>async def get_element_url(\n    data_layer: SQLAlchemyDataLayer, thread_id: str, element_id: str\n) -&gt; str | None:\n    \"\"\"Retrieve the URL for accessing an element's file content.\n\n    Examples:\n        &gt;&gt;&gt; data_layer = get_custom_sqlalchemy_data_layer()\n        &gt;&gt;&gt; url = await get_element_url(data_layer, \"thread123\", \"element456\")\n        &gt;&gt;&gt; print(url)  # None if not found, URL string if exists\n\n    Args:\n        data_layer: The SQLAlchemy data layer instance to use for retrieval.\n        thread_id: The unique identifier of the thread containing the element.\n        element_id: The unique identifier of the element to retrieve.\n\n    Returns:\n        str | None: The URL string if the element exists, None otherwise.\n    \"\"\"\n    logger.debug(\n        f\"SQLAlchemy: get_element_url, thread_id={thread_id}, element_id={element_id}\"\n    )\n\n    element_dict: ElementDict = data_layer.get_element(\n        thread_id=thread_id, element_id=element_id\n    )\n\n    if element_dict is None:\n        return None\n\n    return element_dict.url\n</code></pre>"},{"location":"reference/#podflix.utils.chainlit_utils.data_layer.get_read_url_of_file","title":"get_read_url_of_file  <code>async</code>","text":"<pre><code>get_read_url_of_file(thread_id, file_id)\n</code></pre> <p>Retrieve the URL for accessing an file in a thread.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data_layer = ChainlitDataLayer()\n&gt;&gt;&gt; url = await get_read_url_of_file(data_layer, \"thread123\", \"audio.mp3\")\n&gt;&gt;&gt; print(url)  # URL string\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>str</code> <p>The unique identifier of the thread containing the file.</p> required <code>file_id</code> <code>str</code> <p>The file id of the file to retrieve.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The S3 URL string of the file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If S3 storage client is not configured in the data layer.</p> Source code in <code>src/podflix/utils/chainlit_utils/data_layer.py</code> <pre><code>async def get_read_url_of_file(thread_id: str, file_id: str) -&gt; str:\n    \"\"\"Retrieve the URL for accessing an file in a thread.\n\n    Examples:\n        &gt;&gt;&gt; data_layer = ChainlitDataLayer()\n        &gt;&gt;&gt; url = await get_read_url_of_file(data_layer, \"thread123\", \"audio.mp3\")\n        &gt;&gt;&gt; print(url)  # URL string\n\n    Args:\n        thread_id: The unique identifier of the thread containing the file.\n        file_id: The file id of the file to retrieve.\n\n    Returns:\n        str: The S3 URL string of the file.\n\n    Raises:\n        ValueError: If S3 storage client is not configured in the data layer.\n    \"\"\"\n    cl_data_layer = get_data_layer()\n\n    if cl_data_layer.storage_client is None:\n        raise ValueError(\"S3 storage client not set in data layer.\")\n\n    object_key = f\"threads/{thread_id}/files/{file_id}\"\n\n    return await cl_data_layer.storage_client.get_read_url(object_key=object_key)\n</code></pre>"},{"location":"reference/#podflix.utils.chainlit_utils.data_layer.get_s3_storage_client","title":"get_s3_storage_client","text":"<pre><code>get_s3_storage_client()\n</code></pre> <p>Get the S3 storage client configured with environment credentials.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client = get_s3_storage_client()\n&gt;&gt;&gt; isinstance(client, S3StorageClient)\nTrue\n</code></pre> <p>Returns:</p> Name Type Description <code>S3StorageClient</code> <code>S3StorageClient</code> <p>An initialized S3 storage client instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required AWS S3 credentials are not set in environment variables.</p> Source code in <code>src/podflix/utils/chainlit_utils/data_layer.py</code> <pre><code>def get_s3_storage_client() -&gt; S3StorageClient:\n    \"\"\"Get the S3 storage client configured with environment credentials.\n\n    Examples:\n        &gt;&gt;&gt; client = get_s3_storage_client()\n        &gt;&gt;&gt; isinstance(client, S3StorageClient)\n        True\n\n    Returns:\n        S3StorageClient: An initialized S3 storage client instance.\n\n    Raises:\n        ValueError: If required AWS S3 credentials are not set in environment variables.\n    \"\"\"\n    BUCKET_NAME = os.getenv(\"BUCKET_NAME\", None)\n    APP_AWS_ACCESS_KEY = os.getenv(\"APP_AWS_ACCESS_KEY\", None)\n    APP_AWS_SECRET_KEY = os.getenv(\"APP_AWS_SECRET_KEY\", None)\n    APP_AWS_REGION = os.getenv(\"APP_AWS_REGION\", None)\n    DEV_AWS_ENDPOINT = os.getenv(\"DEV_AWS_ENDPOINT\", None)\n\n    if not all(\n        [\n            BUCKET_NAME,\n            APP_AWS_ACCESS_KEY,\n            APP_AWS_SECRET_KEY,\n            APP_AWS_REGION,\n            DEV_AWS_ENDPOINT,\n        ]\n    ):\n        raise ValueError(\"AWS S3 credentials not set in environment variables.\")\n\n    return S3StorageClient(\n        bucket=BUCKET_NAME,\n        region_name=APP_AWS_REGION,\n        aws_access_key_id=APP_AWS_ACCESS_KEY,\n        aws_secret_access_key=APP_AWS_SECRET_KEY,\n        endpoint_url=DEV_AWS_ENDPOINT,\n    )\n</code></pre>"},{"location":"reference/#podflix.utils.chainlit_utils.general","title":"general","text":"<p>Utilies for chainlit UI.</p>"},{"location":"reference/#podflix.utils.chainlit_utils.general.create_message_history_from_db_thread","title":"create_message_history_from_db_thread","text":"<pre><code>create_message_history_from_db_thread(thread)\n</code></pre> <p>Create message history from the thread steps.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; thread = {\"steps\": [{\"type\": \"user_message\", \"output\": \"hello\", \"createdAt\": 1}]}\n&gt;&gt;&gt; history = create_message_history_from_db_thread(thread)\n&gt;&gt;&gt; len(history.messages)\n1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadDict</code> <p>A ThreadDict object containing the conversation thread data.</p> required <p>Returns:</p> Type Description <code>ChatMessageHistory</code> <p>A ChatMessageHistory object containing the processed message history.</p> Source code in <code>src/podflix/utils/chainlit_utils/general.py</code> <pre><code>def create_message_history_from_db_thread(\n    thread: ThreadDict,\n) -&gt; ChatMessageHistory:\n    \"\"\"Create message history from the thread steps.\n\n    Examples:\n        &gt;&gt;&gt; thread = {\"steps\": [{\"type\": \"user_message\", \"output\": \"hello\", \"createdAt\": 1}]}\n        &gt;&gt;&gt; history = create_message_history_from_db_thread(thread)\n        &gt;&gt;&gt; len(history.messages)\n        1\n\n    Args:\n        thread: A ThreadDict object containing the conversation thread data.\n\n    Returns:\n        A ChatMessageHistory object containing the processed message history.\n    \"\"\"\n    message_history = ChatMessageHistory()\n\n    # TODO: This is a workaround to sort the messages based on createdAt.\n    steps_messages = sorted(\n        [\n            message\n            for message in thread[\"steps\"]\n            if message[\"type\"] in [\"user_message\", \"assistant_message\"]\n        ],\n        key=lambda x: x[\"createdAt\"],\n    )\n\n    for steps_message in steps_messages:\n        if steps_message[\"type\"] == \"user_message\":\n            message_history.add_user_message(steps_message[\"output\"])\n        elif steps_message[\"type\"] == \"assistant_message\":\n            message_history.add_ai_message(steps_message[\"output\"])\n        else:\n            logger.warning(f\"Unknown message type: {steps_message['type']}\")\n\n    return message_history\n</code></pre>"},{"location":"reference/#podflix.utils.chainlit_utils.general.get_current_chainlit_thread_id","title":"get_current_chainlit_thread_id","text":"<pre><code>get_current_chainlit_thread_id()\n</code></pre> <p>Get the current Chainlit thread ID.</p> Source code in <code>src/podflix/utils/chainlit_utils/general.py</code> <pre><code>def get_current_chainlit_thread_id() -&gt; str:\n    \"\"\"Get the current Chainlit thread ID.\"\"\"\n    return cl.context.session.thread_id\n</code></pre>"},{"location":"reference/#podflix.utils.chainlit_utils.general.set_extra_user_session_params","title":"set_extra_user_session_params","text":"<pre><code>set_extra_user_session_params(session_id=None, user_id=None, message_history=None)\n</code></pre> <p>Set extra user session parameters for the chainlit session.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; set_extra_user_session_params(session_id=\"test123\")\n&gt;&gt;&gt; cl.user_session.get(\"session_id\")\n'test123'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str | None</code> <p>Optional string representing the session ID. If None, a new UUID is generated.</p> <code>None</code> <code>user_id</code> <code>str | None</code> <p>Optional string representing the user ID. If None, gets from current user session.</p> <code>None</code> <code>message_history</code> <code>ChatMessageHistory | None</code> <p>Optional ChatMessageHistory object. If None, creates new empty history.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>src/podflix/utils/chainlit_utils/general.py</code> <pre><code>def set_extra_user_session_params(\n    session_id: str | None = None,\n    user_id: str | None = None,\n    message_history: ChatMessageHistory | None = None,\n):\n    \"\"\"Set extra user session parameters for the chainlit session.\n\n    Examples:\n        &gt;&gt;&gt; set_extra_user_session_params(session_id=\"test123\")\n        &gt;&gt;&gt; cl.user_session.get(\"session_id\")\n        'test123'\n\n    Args:\n        session_id: Optional string representing the session ID. If None, a new UUID is generated.\n        user_id: Optional string representing the user ID. If None, gets from current user session.\n        message_history: Optional ChatMessageHistory object. If None, creates new empty history.\n\n    Returns:\n        None\n    \"\"\"\n    if session_id is None:\n        session_id = str(uuid4())\n\n    if message_history is None:\n        message_history = ChatMessageHistory()\n\n    check_lf_credentials()\n    lf_cb_handler = LangfuseCallbackHandler()\n\n    cl.user_session.set(\"session_id\", session_id)\n    cl.user_session.set(\"lf_cb_handler\", lf_cb_handler)\n    cl.user_session.set(\"message_history\", message_history)\n\n    langfuse_session_url = get_lf_session_url(session_id=session_id)\n\n    logger.debug(f\"Langfuse Session URL: {langfuse_session_url}\")\n</code></pre>"},{"location":"reference/#podflix.utils.chainlit_utils.general.set_mock_elements","title":"set_mock_elements  <code>async</code>","text":"<pre><code>set_mock_elements()\n</code></pre> <p>Set mock elements for the sidebar.</p> Source code in <code>src/podflix/utils/chainlit_utils/general.py</code> <pre><code>async def set_mock_elements():\n    \"\"\"Set mock elements for the sidebar.\"\"\"\n    sidebar_mock_elements = [\n        cl.Text(content=\"Here is a side text document\", name=\"text1\"),\n        cl.Image(\n            path=f\"{env_settings.library_base_path}/configs/chainlit/public/banner.png\",\n            name=\"banner\",\n        ),\n    ]\n\n    await cl.ElementSidebar.set_elements(sidebar_mock_elements)\n    await cl.ElementSidebar.set_title(\"Sidebar Mock Title\")\n</code></pre>"},{"location":"reference/#podflix.utils.chainlit_utils.general.simple_auth_callback","title":"simple_auth_callback","text":"<pre><code>simple_auth_callback(username, password)\n</code></pre> <p>Authenticate user with simple username and password check.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; simple_auth_callback(\"admin\", \"admin\")\nUser(identifier=\"admin\", metadata={\"role\": \"admin\", \"provider\": \"credentials\"})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>A string representing the username for authentication.</p> required <code>password</code> <code>str</code> <p>A string representing the password for authentication.</p> required <p>Returns:</p> Type Description <code>User</code> <p>A User object if authentication is successful.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If credentials are invalid.</p> Source code in <code>src/podflix/utils/chainlit_utils/general.py</code> <pre><code>def simple_auth_callback(username: str, password: str) -&gt; User:\n    \"\"\"Authenticate user with simple username and password check.\n\n    Examples:\n        &gt;&gt;&gt; simple_auth_callback(\"admin\", \"admin\")\n        User(identifier=\"admin\", metadata={\"role\": \"admin\", \"provider\": \"credentials\"})\n\n    Args:\n        username: A string representing the username for authentication.\n        password: A string representing the password for authentication.\n\n    Returns:\n        A User object if authentication is successful.\n\n    Raises:\n        ValueError: If credentials are invalid.\n    \"\"\"\n    if (username, password) == (\n        env_settings.chainlit_user_name,\n        env_settings.chainlit_user_password,\n    ):\n        return cl.User(\n            identifier=username, metadata={\"role\": \"admin\", \"provider\": \"credentials\"}\n        )\n\n    raise ValueError(\"Invalid credentials\")\n</code></pre>"},{"location":"reference/#podflix.utils.chainlit_utils.patch_chainlit","title":"patch_chainlit","text":""},{"location":"reference/#podflix.utils.chainlit_utils.patch_chainlit.custom_resume_thread","title":"custom_resume_thread  <code>async</code>","text":"<pre><code>custom_resume_thread(session)\n</code></pre> <p>Resume a thread and set the user session parameters.</p> <p>NOTE: This is a workaround to fix the issue of the chatbot not resuming the thread on sqlite data layer.</p> Source code in <code>src/podflix/utils/chainlit_utils/patch_chainlit.py</code> <pre><code>async def custom_resume_thread(session: WebsocketSession):\n    \"\"\"Resume a thread and set the user session parameters.\n\n    NOTE: This is a workaround to fix the issue of the chatbot not resuming the thread\n    on sqlite data layer.\n    \"\"\"\n    data_layer = get_data_layer()\n    if not data_layer or not session.user or not session.thread_id_to_resume:\n        return\n    thread = await data_layer.get_thread(thread_id=session.thread_id_to_resume)\n    if not thread:\n        return\n\n    author = thread.get(\"userIdentifier\")\n    user_is_author = author == session.user.identifier\n\n    if user_is_author:\n        metadata = thread.get(\"metadata\") or {}\n\n        # NOTE: Original code\n        # user_sessions[session.id] = metadata.copy()\n\n        # NOTE: Patched code\n        if isinstance(metadata, str):\n            try:\n                metadata = json.loads(metadata)\n            except json.JSONDecodeError:\n                metadata = {}\n\n        if isinstance(metadata, dict):\n            user_sessions[session.id] = metadata.copy()\n        else:\n            user_sessions[session.id] = {}\n        # End of patch\n\n        if chat_profile := metadata.get(\"chat_profile\"):\n            session.chat_profile = chat_profile\n        if chat_settings := metadata.get(\"chat_settings\"):\n            session.chat_settings = chat_settings\n\n        trace_event(\"thread_resumed\")\n\n        return thread\n</code></pre>"},{"location":"reference/#podflix.utils.chainlit_utils.setting_widgets","title":"setting_widgets","text":"<p>Utility functions for converting Pydantic models to Chainlit settings.</p>"},{"location":"reference/#podflix.utils.chainlit_utils.setting_widgets.convert_pydantic_model_to_chainlit_settings","title":"convert_pydantic_model_to_chainlit_settings","text":"<pre><code>convert_pydantic_model_to_chainlit_settings(model_class, prefix='')\n</code></pre> <p>Convert a Pydantic model to Chainlit settings.</p> <p>Parameters:</p> Name Type Description Default <code>model_class</code> <code>Type[BaseModel]</code> <p>Pydantic model class to convert</p> required <code>prefix</code> <code>str</code> <p>Prefix for widget labels (e.g., 'OpenAI - ')</p> <code>''</code> <p>Returns:</p> Type Description <code>ChatSettings</code> <p>cl.ChatSettings instance</p> Source code in <code>src/podflix/utils/chainlit_utils/setting_widgets.py</code> <pre><code>def convert_pydantic_model_to_chainlit_settings(\n    model_class: Type[BaseModel], prefix: str = \"\"\n) -&gt; cl.ChatSettings:\n    \"\"\"Convert a Pydantic model to Chainlit settings.\n\n    Args:\n        model_class: Pydantic model class to convert\n        prefix: Prefix for widget labels (e.g., 'OpenAI - ')\n\n    Returns:\n        cl.ChatSettings instance\n    \"\"\"\n    settings = model_class()\n    model_fields = model_class.model_fields\n    chat_settings = []\n\n    for field_name, field_info in model_fields.items():\n        current_value = getattr(settings, field_name)\n        field_type = field_info.annotation\n        description = field_info.description\n        json_schema_extra = field_info.json_schema_extra or {}\n        metadata = field_info.metadata or []\n\n        label = f\"{prefix}{field_name.replace('_', ' ').title()}\"\n\n        # Default widget mapping\n        if field_type is bool:\n            chat_settings.append(\n                Switch(\n                    id=field_name,\n                    label=label,\n                    initial=current_value,\n                    description=description,\n                )\n            )\n        elif field_type in (float, int):\n            min_val = None\n            max_val = None\n\n            # Extract min/max from metadata\n            for constraint in metadata:\n                if hasattr(constraint, \"ge\"):\n                    min_val = constraint.ge\n                elif hasattr(constraint, \"le\"):\n                    max_val = constraint.le\n\n            # Use defaults if not found in metadata\n            min_val = min_val if min_val is not None else -100\n            max_val = max_val if max_val is not None else 32000\n            step = 0.1 if field_type is float else 1\n\n            chat_settings.append(\n                Slider(\n                    id=field_name,\n                    label=label,\n                    initial=current_value,\n                    min=min_val,\n                    max=max_val,\n                    step=step,\n                    description=description,\n                )\n            )\n        elif \"choices\" in json_schema_extra:\n            choices = json_schema_extra[\"choices\"]\n            if not isinstance(choices[0], str):\n                logger.debug(f\"Skipping {field_name} due to non-string choices\")\n                continue\n\n            chat_settings.append(\n                Select(\n                    id=field_name,\n                    label=label,\n                    initial_value=current_value,\n                    values=choices,\n                    description=description,\n                )\n            )\n\n    return cl.ChatSettings(chat_settings)\n</code></pre>"},{"location":"reference/#podflix.utils.chainlit_utils.setting_widgets.get_openai_chat_settings","title":"get_openai_chat_settings","text":"<pre><code>get_openai_chat_settings()\n</code></pre> <p>Get chat settings for OpenAI chat completion parameters.</p> Source code in <code>src/podflix/utils/chainlit_utils/setting_widgets.py</code> <pre><code>def get_openai_chat_settings():\n    \"\"\"Get chat settings for OpenAI chat completion parameters.\"\"\"\n    return convert_pydantic_model_to_chainlit_settings(\n        model_class=OpenAIChatGenerationSettings\n    )\n</code></pre>"},{"location":"reference/#podflix.utils.general","title":"general","text":"<p>General utility functions.</p>"},{"location":"reference/#podflix.utils.general.check_env_vars","title":"check_env_vars","text":"<pre><code>check_env_vars(env_vars=None)\n</code></pre> <p>Checks if the required environment variables are set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; check_env_vars(['API_KEY', 'SECRET_KEY'])\nNone\n&gt;&gt;&gt; check_env_vars(None)\nNone\n&gt;&gt;&gt; check_env_vars(['NONEXISTENT_VAR'])\nTraceback (most recent call last):\nValueError: Please set NONEXISTENT_VAR env var.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>env_vars</code> <code>list[str] | None</code> <p>List of environment variables to check. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the environment variables are not set.</p> Source code in <code>src/podflix/utils/general.py</code> <pre><code>def check_env_vars(env_vars: list[str] | None = None) -&gt; None:\n    \"\"\"Checks if the required environment variables are set.\n\n    Examples:\n        &gt;&gt;&gt; check_env_vars(['API_KEY', 'SECRET_KEY'])\n        None\n        &gt;&gt;&gt; check_env_vars(None)\n        None\n        &gt;&gt;&gt; check_env_vars(['NONEXISTENT_VAR'])\n        Traceback (most recent call last):\n        ValueError: Please set NONEXISTENT_VAR env var.\n\n    Args:\n        env_vars: List of environment variables to check. Defaults to None.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If any of the environment variables are not set.\n    \"\"\"\n    if env_vars is None:\n        return\n\n    for env_var in env_vars:\n        if os.getenv(env_var) is None:\n            raise ValueError(f\"Please set {env_var} env var.\")\n</code></pre>"},{"location":"reference/#podflix.utils.general.check_lf_credentials","title":"check_lf_credentials","text":"<pre><code>check_lf_credentials()\n</code></pre> <p>Check if the Langfuse credentials are correct by attempting authentication.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; check_lf_credentials()\nNone\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If authentication fails with provided Langfuse credentials</p> <code>Exception</code> <p>If Langfuse authentication check fails for any other reason</p> Source code in <code>src/podflix/utils/general.py</code> <pre><code>def check_lf_credentials() -&gt; None:\n    \"\"\"Check if the Langfuse credentials are correct by attempting authentication.\n\n    Examples:\n        &gt;&gt;&gt; check_lf_credentials()\n        None\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If authentication fails with provided Langfuse credentials\n        Exception: If Langfuse authentication check fails for any other reason\n    \"\"\"\n    try:\n        client = get_client()\n        lf_check_result = client.auth_check()\n\n        if lf_check_result is False:\n            raise Exception(\"Langfuse Auth Check Failed\")\n\n        logger.debug(\"Langfuse Auth Check Passed\")\n    except Exception as e:\n        logger.error(f\"Langfuse Auth Check Error: {e}\")\n        raise e\n</code></pre>"},{"location":"reference/#podflix.utils.general.get_lf_project_id","title":"get_lf_project_id","text":"<pre><code>get_lf_project_id()\n</code></pre> <p>Retrieve the Langfuse project ID from the first available project.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_lf_project_id()\n'cm5a4jaff0006r8yk44cvas5a'\n</code></pre> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier of the first Langfuse project.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no projects are found or if there's an error accessing Langfuse API</p> Source code in <code>src/podflix/utils/general.py</code> <pre><code>def get_lf_project_id() -&gt; str:\n    \"\"\"Retrieve the Langfuse project ID from the first available project.\n\n    Examples:\n        &gt;&gt;&gt; get_lf_project_id()\n        'cm5a4jaff0006r8yk44cvas5a'\n\n    Returns:\n        str: The unique identifier of the first Langfuse project.\n\n    Raises:\n        Exception: If no projects are found or if there's an error accessing Langfuse API\n    \"\"\"\n    client = get_client()\n    # projects = client.api.projects.get()\n    # return projects.data[0].id\n    project_id = client._get_project_id()\n\n    if not project_id:\n        raise Exception(\"No Langfuse projects found or unable to access Langfuse API\")\n\n    return project_id\n</code></pre>"},{"location":"reference/#podflix.utils.general.get_lf_session_url","title":"get_lf_session_url","text":"<pre><code>get_lf_session_url(session_id)\n</code></pre> <p>Construct the full URL for a Langfuse session.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_lf_session_url(\"123\")\n'https://YOUR_LANFUSE_HOST/project/YOUR_PROJECT_ID/sessions/123'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The unique identifier of the Langfuse session.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The complete URL to access the session in Langfuse UI.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If there's an error retrieving the project ID</p> Source code in <code>src/podflix/utils/general.py</code> <pre><code>def get_lf_session_url(session_id: str) -&gt; str:\n    \"\"\"Construct the full URL for a Langfuse session.\n\n    Examples:\n        &gt;&gt;&gt; get_lf_session_url(\"123\")\n        'https://YOUR_LANFUSE_HOST/project/YOUR_PROJECT_ID/sessions/123'\n\n    Args:\n        session_id: The unique identifier of the Langfuse session.\n\n    Returns:\n        str: The complete URL to access the session in Langfuse UI.\n\n    Raises:\n        Exception: If there's an error retrieving the project ID\n    \"\"\"\n    langfuse_project_id = get_lf_project_id()\n\n    return f\"{env_settings.langfuse_host}/project/{langfuse_project_id}/sessions/{session_id}\"\n</code></pre>"},{"location":"reference/#podflix.utils.general.get_lf_trace_url","title":"get_lf_trace_url","text":"<pre><code>get_lf_trace_url(langchain_trace_id)\n</code></pre> <p>Construct the full URL for a Langfuse trace.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_lf_trace_url(\"123\")\n'https://YOUR_LANFUSE_HOST/project/YOUR_PROJECT_ID/traces/123'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>langchain_trace_id</code> <code>str</code> <p>The unique identifier of the Langchain trace.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The complete URL to access the trace in Langfuse UI.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If langchain_trace_id is None</p> <code>Exception</code> <p>If there's an error retrieving the project ID</p> Source code in <code>src/podflix/utils/general.py</code> <pre><code>def get_lf_trace_url(langchain_trace_id: str) -&gt; str:\n    \"\"\"Construct the full URL for a Langfuse trace.\n\n    Examples:\n        &gt;&gt;&gt; get_lf_trace_url(\"123\")\n        'https://YOUR_LANFUSE_HOST/project/YOUR_PROJECT_ID/traces/123'\n\n    Args:\n        langchain_trace_id: The unique identifier of the Langchain trace.\n\n    Returns:\n        str: The complete URL to access the trace in Langfuse UI.\n\n    Raises:\n        ValueError: If langchain_trace_id is None\n        Exception: If there's an error retrieving the project ID\n    \"\"\"\n    if langchain_trace_id is None:\n        raise ValueError(\"langchain_trace_id cannot be None\")\n\n    client = get_client()\n    url = client.get_trace_url(trace_id=langchain_trace_id)\n\n    if url is None:\n        raise Exception(\"Unable to construct Langfuse trace URL\")\n\n    return url\n</code></pre>"},{"location":"reference/#podflix.utils.general.is_module_installed","title":"is_module_installed","text":"<pre><code>is_module_installed(module_name, throw_error=False)\n</code></pre> <p>Check if the module is installed or not.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_module_installed(module_name=\"yaml\", throw_error=False)\nTrue\n&gt;&gt;&gt; is_module_installed(module_name=\"numpy\", throw_error=False)\nFalse\n&gt;&gt;&gt; is_module_installed(module_name=\"numpy\", throw_error=True)\nTraceback (most recent call last):\nImportError: Module numpy is not installed.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Name of the module to be checked.</p> required <code>throw_error</code> <code>bool</code> <p>If True, raises ImportError if module is not installed.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Returns True if module is installed, False otherwise.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If throw_error is True and module is not installed.</p> Source code in <code>src/podflix/utils/general.py</code> <pre><code>def is_module_installed(module_name: str, throw_error: bool = False) -&gt; bool:\n    \"\"\"Check if the module is installed or not.\n\n    Examples:\n        &gt;&gt;&gt; is_module_installed(module_name=\"yaml\", throw_error=False)\n        True\n        &gt;&gt;&gt; is_module_installed(module_name=\"numpy\", throw_error=False)\n        False\n        &gt;&gt;&gt; is_module_installed(module_name=\"numpy\", throw_error=True)\n        Traceback (most recent call last):\n        ImportError: Module numpy is not installed.\n\n    Args:\n        module_name: Name of the module to be checked.\n        throw_error: If True, raises ImportError if module is not installed.\n\n    Returns:\n        Returns True if module is installed, False otherwise.\n\n    Raises:\n        ImportError: If throw_error is True and module is not installed.\n    \"\"\"\n    try:\n        importlib.import_module(module_name)\n        return True\n    except ImportError as e:\n        if throw_error:\n            message = f\"Module {module_name} is not installed.\"\n            raise ImportError(message) from e\n        return False\n</code></pre>"},{"location":"reference/#podflix.utils.graph_runner","title":"graph_runner","text":"<p>Helper class for running the graph.</p>"},{"location":"reference/#podflix.utils.graph_runner.GraphRunner","title":"GraphRunner","text":"<pre><code>GraphRunner(\n    graph,\n    graph_inputs,\n    graph_streamable_node_names,\n    lf_cb_handler,\n    user_id,\n    session_id,\n    assistant_message,\n)\n</code></pre> <p>Helper class for on_message callback.</p> <p>Initialize the GraphRunner class.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>CompiledStateGraph</code> <p>A CompiledStateGraph instance representing the graph to be executed.</p> required <code>graph_inputs</code> <code>dict</code> <p>A dictionary containing the inputs for the graph.</p> required <code>graph_streamable_node_names</code> <code>list[str]</code> <p>A list of node names that can be streamed.</p> required <code>lf_cb_handler</code> <code>CallbackHandler</code> <p>A LangfuseCallbackHandler instance for tracking.</p> required <code>user_id</code> <code>str</code> <p>A string representing the unique user identifier.</p> required <code>session_id</code> <code>str</code> <p>A string representing the unique session identifier.</p> required <code>assistant_message</code> <code>Message</code> <p>A chainlit Message instance for displaying responses.</p> required Source code in <code>src/podflix/utils/graph_runner.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    graph: CompiledStateGraph,\n    graph_inputs: dict,\n    graph_streamable_node_names: list[str],\n    lf_cb_handler: LangfuseCallbackHandler,\n    user_id: str,\n    session_id: str,\n    assistant_message: cl.Message,\n):\n    \"\"\"Initialize the GraphRunner class.\n\n    Args:\n        graph: A CompiledStateGraph instance representing the graph to be executed.\n        graph_inputs: A dictionary containing the inputs for the graph.\n        graph_streamable_node_names: A list of node names that can be streamed.\n        lf_cb_handler: A LangfuseCallbackHandler instance for tracking.\n        user_id: A string representing the unique user identifier.\n        session_id: A string representing the unique session identifier.\n        assistant_message: A chainlit Message instance for displaying responses.\n    \"\"\"\n    self.graph = graph\n    self.graph_inputs = graph_inputs\n    self.graph_streamable_node_names = graph_streamable_node_names\n    self.lf_cb_handler = lf_cb_handler\n    self.user_id = user_id\n    self.session_id = session_id\n    self.assistant_message = assistant_message\n\n    self.run_id = None\n</code></pre>"},{"location":"reference/#podflix.utils.graph_runner.GraphRunner.run_graph","title":"run_graph  <code>async</code>","text":"<pre><code>run_graph()\n</code></pre> <p>Execute the graph asynchronously with the configured inputs.</p> <p>This method sets up the runnable configuration with callbacks and streams the graph events to process the LLM responses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; runner = GraphRunner(graph, inputs, nodes, handler, \"session1\", message)\n&gt;&gt;&gt; await runner.run_graph()\n</code></pre> <p>Returns:</p> Type Description <p>None</p> Source code in <code>src/podflix/utils/graph_runner.py</code> <pre><code>async def run_graph(self):\n    \"\"\"Execute the graph asynchronously with the configured inputs.\n\n    This method sets up the runnable configuration with callbacks and streams\n    the graph events to process the LLM responses.\n\n    Examples:\n        &gt;&gt;&gt; runner = GraphRunner(graph, inputs, nodes, handler, \"session1\", message)\n        &gt;&gt;&gt; await runner.run_graph()\n\n    Returns:\n        None\n    \"\"\"\n    graph_runnable_config = RunnableConfig(\n        callbacks=[\n            self.lf_cb_handler,\n            cl.LangchainCallbackHandler(),\n        ],\n        recursion_limit=10,\n        configurable={\"session_id\": self.session_id},\n        metadata={\n            \"langfuse_user_id\": self.user_id,\n            \"langfuse_session_id\": self.session_id,\n            # \"langfuse_tags\": [\"test_tag\"],\n        },\n    )\n\n    async for event in self.graph.astream_events(\n        self.graph_inputs,\n        config=graph_runnable_config,\n        version=\"v2\",\n    ):\n        await self.stream_llm_response(event)\n</code></pre>"},{"location":"reference/#podflix.utils.graph_runner.GraphRunner.stream_llm_response","title":"stream_llm_response  <code>async</code>","text":"<pre><code>stream_llm_response(event)\n</code></pre> <p>Stream the LLM response to the assistant message.</p> <p>Process the event data and stream tokens to the assistant message if the event comes from a streamable node.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; event = {\"event\": \"on_chat_model_stream\", \"data\": {\"chunk\": chunk}}\n&gt;&gt;&gt; await runner.stream_llm_response(event)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>dict</code> <p>A dictionary containing the event data with the following structure:   - event: The type of event (str)   - metadata: Dictionary with event metadata   - data: The event payload</p> required <p>Returns:</p> Type Description <p>None</p> Notes <p>The method updates the assistant_message.content when streaming tokens. It also captures the run_id for Langfuse tracking when the chain ends.</p> Source code in <code>src/podflix/utils/graph_runner.py</code> <pre><code>async def stream_llm_response(self, event: dict):\n    \"\"\"Stream the LLM response to the assistant message.\n\n    Process the event data and stream tokens to the assistant message if the\n    event comes from a streamable node.\n\n    Examples:\n        &gt;&gt;&gt; event = {\"event\": \"on_chat_model_stream\", \"data\": {\"chunk\": chunk}}\n        &gt;&gt;&gt; await runner.stream_llm_response(event)\n\n    Args:\n        event: A dictionary containing the event data with the following structure:\n              - event: The type of event (str)\n              - metadata: Dictionary with event metadata\n              - data: The event payload\n\n    Returns:\n        None\n\n    Notes:\n        The method updates the assistant_message.content when streaming tokens.\n        It also captures the run_id for Langfuse tracking when the chain ends.\n    \"\"\"\n    event_kind = event[\"event\"]\n    langgraph_node = event[\"metadata\"].get(\"langgraph_node\", None)\n\n    if event_kind == \"on_chat_model_stream\":\n        if langgraph_node not in self.graph_streamable_node_names:\n            return\n\n        ai_message_chunk: AIMessageChunk = event[\"data\"][\"chunk\"]\n        ai_message_content = ai_message_chunk.content\n\n        if ai_message_content:\n            # NOTE: This automatically updates the assistant_message.content\n            await self.assistant_message.stream_token(ai_message_content)\n\n    # TODO: Find out more robust way to get run_id for langfuse\n    if event[\"event\"] == \"on_chain_end\":\n        run_id = event.get(\"run_id\")\n        self.run_id = run_id\n        logger.debug(f\"Langfuse Run ID: {run_id}\")\n</code></pre>"},{"location":"reference/#podflix.utils.hf_related","title":"hf_related","text":"<p>Hugginface related utilities.</p>"},{"location":"reference/#podflix.utils.hf_related.download_gguf_hf","title":"download_gguf_hf","text":"<pre><code>download_gguf_hf(repo_id, filename, revision='main')\n</code></pre> <p>Download a specific GGUF file from Hugging Face hub.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; download_gguf_hf(\"Qwen/Qwen2-0.5B-Instruct-GGUF\", \"qwen2-0_5b-instruct-fp16.gguf\")\n'/path/to/downloaded/file.gguf'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>repo_id</code> <code>str</code> <p>A string representing the Hugging Face repository ID.</p> required <code>filename</code> <code>str</code> <p>A string representing the name of the GGUF file to download.</p> required <code>revision</code> <code>str</code> <p>A string representing the specific model version to use.</p> <code>'main'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Local path to the downloaded file.</p> Source code in <code>src/podflix/utils/hf_related.py</code> <pre><code>def download_gguf_hf(\n    repo_id: str,\n    filename: str,\n    revision: str = \"main\",\n) -&gt; str:\n    \"\"\"Download a specific GGUF file from Hugging Face hub.\n\n    Examples:\n        &gt;&gt;&gt; download_gguf_hf(\"Qwen/Qwen2-0.5B-Instruct-GGUF\", \"qwen2-0_5b-instruct-fp16.gguf\")\n        '/path/to/downloaded/file.gguf'\n\n    Args:\n        repo_id: A string representing the Hugging Face repository ID.\n        filename: A string representing the name of the GGUF file to download.\n        revision: A string representing the specific model version to use.\n\n    Returns:\n        str: Local path to the downloaded file.\n    \"\"\"\n    return hf_hub_download(\n        repo_id=repo_id,\n        filename=filename,\n        revision=revision,\n        local_dir=f\"{env_settings.library_base_path}/deployment/models/GGUF\",\n        token=env_settings.hf_token,\n    )\n</code></pre>"},{"location":"reference/#podflix.utils.hf_related.download_model_snapshot_hf","title":"download_model_snapshot_hf","text":"<pre><code>download_model_snapshot_hf(\n    repo_id=\"Qwen/Qwen2.5-0.5B-Instruct\", revision=\"main\", ignore_patterns=None\n)\n</code></pre> <p>Download a complete model snapshot from Hugging Face hub.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; download_model_snapshot_hf(\"Qwen/Qwen2.5-0.5B-Instruct\")\n&gt;&gt;&gt; download_model_snapshot_hf(\"Qwen/Qwen2.5-0.5B-Instruct\", ignore_patterns=[\"*.pt\"])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>repo_id</code> <code>str</code> <p>A string representing the Hugging Face repository ID.</p> <code>'Qwen/Qwen2.5-0.5B-Instruct'</code> <code>revision</code> <code>str</code> <p>A string representing the specific model version to use.</p> <code>'main'</code> <code>ignore_patterns</code> <code>list[str] | None</code> <p>A list of patterns to ignore during download.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/podflix/utils/hf_related.py</code> <pre><code>def download_model_snapshot_hf(\n    repo_id: str = \"Qwen/Qwen2.5-0.5B-Instruct\",\n    revision: str = \"main\",\n    ignore_patterns: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Download a complete model snapshot from Hugging Face hub.\n\n    Examples:\n        &gt;&gt;&gt; download_model_snapshot_hf(\"Qwen/Qwen2.5-0.5B-Instruct\")\n        &gt;&gt;&gt; download_model_snapshot_hf(\"Qwen/Qwen2.5-0.5B-Instruct\", ignore_patterns=[\"*.pt\"])\n\n    Args:\n        repo_id: A string representing the Hugging Face repository ID.\n        revision: A string representing the specific model version to use.\n        ignore_patterns: A list of patterns to ignore during download.\n\n    Returns:\n        None\n    \"\"\"\n    local_dir_name = repo_id.split(\"/\")[1]\n\n    if ignore_patterns is None:\n        ignore_patterns = [\"*.pt\"]\n\n    snapshot_download(\n        repo_id=repo_id,\n        revision=revision,\n        local_dir=f\"{env_settings.library_base_path}/deployment/models/{local_dir_name}\",\n        ignore_patterns=ignore_patterns,\n        token=env_settings.hf_token,\n    )\n</code></pre>"},{"location":"reference/#podflix.utils.model","title":"model","text":"<p>Model utilities.</p>"},{"location":"reference/#podflix.utils.model.get_chat_model","title":"get_chat_model","text":"<pre><code>get_chat_model(model_name=None, chat_model_kwargs=None)\n</code></pre> <p>Create and configure a ChatOpenAI model instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model = get_chat_model()\n&gt;&gt;&gt; isinstance(model, ChatOpenAI)\nTrue\n&gt;&gt;&gt; model = get_chat_model(\"gpt-4o-mini\", {\"temperature\": 0.7})\n&gt;&gt;&gt; isinstance(model, ChatOpenAI)\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str | None</code> <p>The name of the model to use. If None, uses the default from env_settings.</p> <code>None</code> <code>chat_model_kwargs</code> <code>dict[Any] | None</code> <p>Additional keyword arguments to pass to ChatOpenAI. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ChatOpenAI</code> <p>A configured ChatOpenAI model instance ready for use.</p> Source code in <code>src/podflix/utils/model.py</code> <pre><code>def get_chat_model(\n    model_name: str | None = None,\n    chat_model_kwargs: dict[Any] | None = None,\n) -&gt; ChatOpenAI:\n    \"\"\"Create and configure a ChatOpenAI model instance.\n\n    Examples:\n        &gt;&gt;&gt; model = get_chat_model()\n        &gt;&gt;&gt; isinstance(model, ChatOpenAI)\n        True\n        &gt;&gt;&gt; model = get_chat_model(\"gpt-4o-mini\", {\"temperature\": 0.7})\n        &gt;&gt;&gt; isinstance(model, ChatOpenAI)\n        True\n\n    Args:\n        model_name: The name of the model to use. If None, uses the default from env_settings.\n        chat_model_kwargs: Additional keyword arguments to pass to ChatOpenAI. Defaults to None.\n\n    Returns:\n        A configured ChatOpenAI model instance ready for use.\n    \"\"\"\n    if chat_model_kwargs is None:\n        chat_model_kwargs = {}\n\n    openai_api_base = f\"{env_settings.model_api_base}/v1\"\n\n    if model_name is None:\n        model_name = env_settings.model_name\n\n    if env_settings.enable_openai_api is True:\n        openai_api_key = env_settings.openai_api_key\n    else:\n        openai_api_key = \"DUMMY_KEY\"\n\n    return ChatOpenAI(\n        model_name=model_name,\n        openai_api_base=openai_api_base,\n        openai_api_key=openai_api_key,\n        **chat_model_kwargs,\n    )\n</code></pre>"},{"location":"reference/#podflix.utils.model.get_mock_model","title":"get_mock_model","text":"<pre><code>get_mock_model(message='MOCK MESSAGE')\n</code></pre> <p>Create a mock language model for testing purposes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model = get_mock_model(\"Test response\")\n&gt;&gt;&gt; isinstance(model, (FakeListChatModel, StrOutputParser))\nTrue\n&gt;&gt;&gt; model = get_mock_model()\n&gt;&gt;&gt; isinstance(model, (FakeListChatModel, StrOutputParser))\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to be returned by the mock model. Defaults to \"MOCK MESSAGE\".</p> <code>'MOCK MESSAGE'</code> <p>Returns:</p> Type Description <code>FakeListChatModel | StrOutputParser</code> <p>A chain of FakeListChatModel and StrOutputParser that returns the specified message.</p> Source code in <code>src/podflix/utils/model.py</code> <pre><code>def get_mock_model(\n    message: str = \"MOCK MESSAGE\",\n) -&gt; FakeListChatModel | StrOutputParser:\n    \"\"\"Create a mock language model for testing purposes.\n\n    Examples:\n        &gt;&gt;&gt; model = get_mock_model(\"Test response\")\n        &gt;&gt;&gt; isinstance(model, (FakeListChatModel, StrOutputParser))\n        True\n        &gt;&gt;&gt; model = get_mock_model()\n        &gt;&gt;&gt; isinstance(model, (FakeListChatModel, StrOutputParser))\n        True\n\n    Args:\n        message: The message to be returned by the mock model. Defaults to \"MOCK MESSAGE\".\n\n    Returns:\n        A chain of FakeListChatModel and StrOutputParser that returns the specified message.\n    \"\"\"\n    model = FakeListChatModel(responses=[message])\n\n    return model | StrOutputParser()\n</code></pre>"},{"location":"reference/#podflix.utils.model.transcribe_audio_file","title":"transcribe_audio_file  <code>async</code>","text":"<pre><code>transcribe_audio_file(file, model_name=None, response_format='verbose_json')\n</code></pre> <p>Transcribe an audio file using OpenAI's Whisper model.</p> <p>When using the verbose_json response format, the function returns the transcribed text with optional timestamps. Otherwise, it returns only the transcribed text.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with open('audio.mp3', 'rb') as f:\n...     transcription = transcribe_audio_file(f)\n&gt;&gt;&gt; isinstance(transcription.text, str)\nTrue\n&gt;&gt;&gt; transcription = transcribe_audio_file(Path('audio.mp3'))\n&gt;&gt;&gt; isinstance(transcription.text, str)\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>BinaryIO | Path</code> <p>The audio file to transcribe. Can be a file object or Path.</p> required <code>model_name</code> <code>str | None</code> <p>The name of the Whisper model to use. If None, uses the default from env_settings.</p> <code>None</code> <code>response_format</code> <code>AudioResponseFormat</code> <p>The format of the response to return. Defaults to \"verbose_json\".</p> <code>'verbose_json'</code> <p>Returns:</p> Type Description <code>Transcription | TranscriptionVerbose</code> <p>The transcribed text with optional timestamps from the audio file.</p> Source code in <code>src/podflix/utils/model.py</code> <pre><code>async def transcribe_audio_file(\n    file: BinaryIO | Path,\n    model_name: str | None = None,\n    response_format: AudioResponseFormat = \"verbose_json\",\n) -&gt; Transcription | TranscriptionVerbose:\n    \"\"\"Transcribe an audio file using OpenAI's Whisper model.\n\n    When using the verbose_json response format, the function returns the transcribed text with optional timestamps.\n    Otherwise, it returns only the transcribed text.\n\n    Examples:\n        &gt;&gt;&gt; with open('audio.mp3', 'rb') as f:\n        ...     transcription = transcribe_audio_file(f)\n        &gt;&gt;&gt; isinstance(transcription.text, str)\n        True\n        &gt;&gt;&gt; transcription = transcribe_audio_file(Path('audio.mp3'))\n        &gt;&gt;&gt; isinstance(transcription.text, str)\n        True\n\n    Args:\n        file: The audio file to transcribe. Can be a file object or Path.\n        model_name: The name of the Whisper model to use. If None, uses the default from env_settings.\n        response_format: The format of the response to return. Defaults to \"verbose_json\".\n\n    Returns:\n        The transcribed text with optional timestamps from the audio file.\n    \"\"\"\n    if model_name is None:\n        model_name = env_settings.whisper_model_name\n\n    if env_settings.enable_openai_api is True:\n        openai_api_key = env_settings.openai_api_key\n    else:\n        openai_api_key = \"DUMMY_KEY\"\n\n    client = AsyncOpenAI(\n        base_url=f\"{env_settings.whisper_api_base}/v1\", api_key=openai_api_key\n    )\n\n    if isinstance(file, Path):\n        file = file.open(\"rb\")\n\n    try:\n        return await client.audio.transcriptions.create(\n            model=model_name, file=file, response_format=response_format\n        )\n    finally:\n        if isinstance(file, Path):\n            file.close()\n</code></pre>"},{"location":"reference/#podflix.utils.pydantic_models","title":"pydantic_models","text":"<p>Pydantic models for Podflix.</p>"},{"location":"reference/#podflix.utils.pydantic_models.OpenAIChatGenerationSettings","title":"OpenAIChatGenerationSettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model for OpenAI chat settings.</p>"},{"location":"reference/#podflix.utils.pydantic_models.get_available_models","title":"get_available_models","text":"<pre><code>get_available_models()\n</code></pre> <p>Return available models based on environment settings.</p> Source code in <code>src/podflix/utils/pydantic_models.py</code> <pre><code>def get_available_models():\n    \"\"\"Return available models based on environment settings.\"\"\"\n    if env_settings.enable_openai_api:\n        return [\"gpt-3.5-turbo\", \"gpt-4\", \"gpt-4o-mini\"]\n    return [env_settings.model_name]\n</code></pre>"},{"location":"reference/#podflix.utils.pydantic_models.get_default_model","title":"get_default_model","text":"<pre><code>get_default_model()\n</code></pre> <p>Return the default model based on environment settings.</p> Source code in <code>src/podflix/utils/pydantic_models.py</code> <pre><code>def get_default_model():\n    \"\"\"Return the default model based on environment settings.\"\"\"\n    return (\n        env_settings.model_name if not env_settings.enable_openai_api else \"gpt-4o-mini\"\n    )\n</code></pre>"},{"location":"reference/#podflix.utils.youtube","title":"youtube","text":"<p>Youtube utilities for downloading audio and subtitles.</p>"},{"location":"reference/#podflix.utils.youtube.AudioSegment","title":"AudioSegment","text":"<p>               Bases: <code>BaseModel</code></p> <p>Audio segments with start and end times.</p>"},{"location":"reference/#podflix.utils.youtube.Transcription","title":"Transcription","text":"<p>               Bases: <code>BaseModel</code></p> <p>Transcription of audio with segments.</p>"},{"location":"reference/#podflix.utils.youtube.TranscriptionFormatter","title":"TranscriptionFormatter","text":"<p>               Bases: <code>Formatter</code></p> <p>Custom formatter that converts FetchedTranscript to Transcription pydantic model.</p>"},{"location":"reference/#podflix.utils.youtube.TranscriptionFormatter.format_transcript","title":"format_transcript","text":"<pre><code>format_transcript(transcript, **kwargs)\n</code></pre> <p>Convert a FetchedTranscript to Transcription pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>transcript</code> <code>FetchedTranscript</code> <p>The FetchedTranscript object from youtube_transcript_api</p> required <code>**kwargs</code> <p>Additional keyword arguments (unused)</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Transcription</code> <code>Transcription</code> <p>A Transcription pydantic model with segments having start/end times</p> Source code in <code>src/podflix/utils/youtube.py</code> <pre><code>def format_transcript(\n    self, transcript: FetchedTranscript, **kwargs\n) -&gt; Transcription:\n    \"\"\"Convert a FetchedTranscript to Transcription pydantic model.\n\n    Args:\n        transcript: The FetchedTranscript object from youtube_transcript_api\n        **kwargs: Additional keyword arguments (unused)\n\n    Returns:\n        Transcription: A Transcription pydantic model with segments having start/end times\n    \"\"\"\n    segments = []\n    full_text = \"\"\n\n    for i, snippet in enumerate(transcript.snippets):\n        # Convert start + duration to start + end format\n        start_time = snippet.start\n        end_time = snippet.start + snippet.duration\n        text = snippet.text.strip()\n\n        segments.append(\n            AudioSegment(\n                id=i,\n                start=start_time,\n                end=end_time,\n                text=text,\n            )\n        )\n\n        full_text += text + \" \"\n\n    return Transcription(\n        text=full_text.strip(),\n        segments=segments,\n    )\n</code></pre>"},{"location":"reference/#podflix.utils.youtube.TranscriptionFormatter.format_transcripts","title":"format_transcripts","text":"<pre><code>format_transcripts(transcripts, **kwargs)\n</code></pre> <p>Convert a list of FetchedTranscripts to a list of Transcription pydantic models.</p> <p>Parameters:</p> Name Type Description Default <code>transcripts</code> <code>List[FetchedTranscript]</code> <p>List of FetchedTranscript objects from youtube_transcript_api</p> required <code>**kwargs</code> <p>Additional keyword arguments (unused)</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Transcription]</code> <p>List[Transcription]: A list of Transcription pydantic models</p> Source code in <code>src/podflix/utils/youtube.py</code> <pre><code>def format_transcripts(\n    self, transcripts: List[FetchedTranscript], **kwargs\n) -&gt; List[Transcription]:\n    \"\"\"Convert a list of FetchedTranscripts to a list of Transcription pydantic models.\n\n    Args:\n        transcripts: List of FetchedTranscript objects from youtube_transcript_api\n        **kwargs: Additional keyword arguments (unused)\n\n    Returns:\n        List[Transcription]: A list of Transcription pydantic models\n    \"\"\"\n    return [\n        self.format_transcript(transcript, **kwargs) for transcript in transcripts\n    ]\n</code></pre>"},{"location":"reference/#podflix.utils.youtube.convert_vtt_to_segments","title":"convert_vtt_to_segments","text":"<pre><code>convert_vtt_to_segments(vtt_content)\n</code></pre> <p>Convert VTT content to a list of AudioSegment.</p> <p>Parameters:</p> Name Type Description Default <code>vtt_content</code> <code>str</code> <p>The content of the VTT file as a string.</p> required <p>Returns:</p> Type Description <code>Transcription</code> <p>A list of AudioSegments.</p> Source code in <code>src/podflix/utils/youtube.py</code> <pre><code>def convert_vtt_to_segments(vtt_content: str) -&gt; Transcription:\n    \"\"\"Convert VTT content to a list of AudioSegment.\n\n    Args:\n        vtt_content: The content of the VTT file as a string.\n\n    Returns:\n        A list of AudioSegments.\n    \"\"\"\n    # Parse VTT content into AudioSegments\n    transcription = Transcription()\n    lines = vtt_content.strip().split(\"\\n\")\n\n    # Skip header lines\n    i = 0\n    while i &lt; len(lines) and not lines[i].strip().replace(\"--&gt;\", \"\").strip():\n        i += 1\n\n    segment_id = 0\n    while i &lt; len(lines):\n        # Skip empty lines\n        if not lines[i].strip():\n            i += 1\n            continue\n\n        # Parse timestamp line\n        if \"--&gt;\" in lines[i]:\n            time_parts = lines[i].split(\"--&gt;\")\n            start_time = _vtt_time_to_seconds(time_parts[0].strip())\n            end_time = _vtt_time_to_seconds(time_parts[1].strip())\n\n            # Collect the text content\n            text_lines = []\n            i += 1\n            while i &lt; len(lines) and lines[i].strip() and \"--&gt;\" not in lines[i]:\n                # Replace &amp;nbsp; with empty string\n                text_line = lines[i].strip().replace(\"&amp;nbsp;\", \"\")\n                text_lines.append(text_line)\n                i += 1\n\n            text = \" \".join(text_lines)\n            # Remove speaker indicators like \"- \" at the beginning\n            text = text.lstrip(\"- \")\n\n            transcription.text += text + \" \"\n\n            transcription.segments.append(\n                AudioSegment(id=segment_id, start=start_time, end=end_time, text=text)\n            )\n            segment_id += 1\n        else:\n            # Skip other non-timestamp lines\n            i += 1\n\n    return transcription\n</code></pre>"},{"location":"reference/#podflix.utils.youtube.download_youtube_audio","title":"download_youtube_audio","text":"<pre><code>download_youtube_audio(url, download_subtitles=False)\n</code></pre> <p>Downloads audio from a YouTube URL and converts it to MP3 format.</p> <p>Optionally downloads subtitles with timestamps.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; audio_path, subs = download_youtube_audio(\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\")\n&gt;&gt;&gt; isinstance(audio_path, Path)\nTrue\n&gt;&gt;&gt; audio_path.suffix\n'.mp3'\n&gt;&gt;&gt; audio_path, subs = download_youtube_audio(\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\", True)\n&gt;&gt;&gt; isinstance(subs, list)\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The YouTube video URL to download audio from.</p> required <code>download_subtitles</code> <code>bool</code> <p>Whether to download and return subtitles. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[Path, list[dict] | None]</code> <p>tuple[Path, list[dict] | None]: A tuple containing: - Path to the downloaded and converted MP3 file - List of subtitle entries with timestamps if download_subtitles=True, None otherwise.   Each subtitle entry is a dict with 'text' and 'start' keys.</p> <p>Raises:</p> Type Description <code>DownloadError</code> <p>If the video cannot be downloaded</p> <code>PostProcessingError</code> <p>If the audio conversion fails</p> Source code in <code>src/podflix/utils/youtube.py</code> <pre><code>def download_youtube_audio(\n    url: str, download_subtitles: bool = False\n) -&gt; tuple[Path, list[dict] | None]:\n    \"\"\"Downloads audio from a YouTube URL and converts it to MP3 format.\n\n    Optionally downloads subtitles with timestamps.\n\n    Examples:\n        &gt;&gt;&gt; audio_path, subs = download_youtube_audio(\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\")\n        &gt;&gt;&gt; isinstance(audio_path, Path)\n        True\n        &gt;&gt;&gt; audio_path.suffix\n        '.mp3'\n        &gt;&gt;&gt; audio_path, subs = download_youtube_audio(\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\", True)\n        &gt;&gt;&gt; isinstance(subs, list)\n        True\n\n    Args:\n        url: The YouTube video URL to download audio from.\n        download_subtitles: Whether to download and return subtitles. Defaults to False.\n\n    Returns:\n        tuple[Path, list[dict] | None]: A tuple containing:\n            - Path to the downloaded and converted MP3 file\n            - List of subtitle entries with timestamps if download_subtitles=True, None otherwise.\n              Each subtitle entry is a dict with 'text' and 'start' keys.\n\n    Raises:\n        DownloadError: If the video cannot be downloaded\n        PostProcessingError: If the audio conversion fails\n    \"\"\"\n    ydl_opts = {\n        \"format\": \"bestaudio/best\",\n        \"postprocessors\": [\n            {\n                \"key\": \"FFmpegExtractAudio\",\n                \"preferredcodec\": \"mp3\",\n                \"preferredquality\": \"192\",\n            }\n        ],\n        \"outtmpl\": f\"{tempfile.gettempdir()}/%(title)s.%(ext)s\",\n        \"writeautomaticsub\": download_subtitles,\n        \"subtitlesformat\": \"json\",\n        \"subtitleslangs\": [\"en\"],\n        \"quiet\": True,\n        \"no_warnings\": True,\n    }\n\n    with YoutubeDL(ydl_opts) as ydl:\n        info = ydl.extract_info(url, download=True)\n        audio_path = Path(f\"{tempfile.gettempdir()}/{info['title']}.mp3\")\n\n        if download_subtitles:\n            subtitles = []\n            if info.get(\"subtitles\") or info.get(\"automatic_captions\"):\n                subs_data = info.get(\"subtitles\", {}).get(\"en\") or info.get(\n                    \"automatic_captions\", {}\n                ).get(\"en\")\n                if subs_data:\n                    for entry in subs_data:\n                        if \"text\" in entry and \"start\" in entry:\n                            subtitles.append(\n                                {\"text\": entry[\"text\"], \"start\": entry[\"start\"]}\n                            )\n            return audio_path, subtitles\n\n        return audio_path, None\n</code></pre>"},{"location":"reference/#podflix.utils.youtube.download_youtube_subtitles","title":"download_youtube_subtitles  <code>async</code>","text":"<pre><code>download_youtube_subtitles(url, language='en', supress_ytdl_output=True)\n</code></pre> <p>Downloads and parses YouTube subtitles into AudioSegments format async.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The YouTube video URL to download subtitles from.</p> required <code>language</code> <code>str</code> <p>The language code for the subtitles. Defaults to \"en\".</p> <code>'en'</code> <code>supress_ytdl_output</code> <code>bool</code> <p>Whether to suppress yt-dlp output. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The content of the downloaded subtitles in VTT format.</p> Source code in <code>src/podflix/utils/youtube.py</code> <pre><code>async def download_youtube_subtitles(\n    url: str, language: str = \"en\", supress_ytdl_output: bool = True\n) -&gt; str:\n    \"\"\"Downloads and parses YouTube subtitles into AudioSegments format async.\n\n    Args:\n        url: The YouTube video URL to download subtitles from.\n        language: The language code for the subtitles. Defaults to \"en\".\n        supress_ytdl_output: Whether to suppress yt-dlp output. Defaults to True.\n\n    Returns:\n        The content of the downloaded subtitles in VTT format.\n    \"\"\"\n    ydl_opts = {\n        \"skip_download\": True,\n        \"writeautomaticsub\": False,  # Download auto-generated subtitles if available\n        \"writesubtitles\": True,  # NOTE: This is required to download the subtitles. But where does it save?\n        \"subtitlesformat\": \"vtt\",\n        \"subtitleslangs\": [language],\n        \"quiet\": supress_ytdl_output,\n        \"no_warnings\": supress_ytdl_output,\n    }\n\n    loop = asyncio.get_running_loop()\n    with ProcessPoolExecutor() as exc:\n        info = await loop.run_in_executor(\n            exc, functools.partial(get_youtube_info, url=url, ydl_opts=ydl_opts)\n        )\n\n    # Check if the requested subtitles are available\n    requested_subs = info.get(\"requested_subtitles\", None)\n\n    if not requested_subs or language not in requested_subs:\n        raise ValueError(f\"Subtitles in {language} are not available for this video.\")\n\n    vtt_url = requested_subs.get(language).get(\"url\")\n\n    async with httpx.AsyncClient() as client:\n        response = await client.get(vtt_url)\n        response.raise_for_status()\n\n    return response.text\n</code></pre>"},{"location":"reference/#podflix.utils.youtube.fetch_youtube_transcription","title":"fetch_youtube_transcription  <code>async</code>","text":"<pre><code>fetch_youtube_transcription(video_url_or_id)\n</code></pre> <p>Fetch YouTube transcript using youtube_transcript_api and convert to Transcription model.</p> <p>Parameters:</p> Name Type Description Default <code>video_url_or_id</code> <code>str</code> <p>YouTube video url or ID (11 characters)</p> required <p>Returns:</p> Name Type Description <code>Transcription</code> <code>Transcription</code> <p>A Transcription pydantic model with segments having start/end times</p> Example <p>transcription = await fetch_youtube_transcript_as_transcription(\"dQw4w9WgXcQ\") isinstance(transcription, Transcription) True len(transcription.segments) &gt; 0 True</p> Source code in <code>src/podflix/utils/youtube.py</code> <pre><code>async def fetch_youtube_transcription(video_url_or_id: str) -&gt; Transcription:\n    \"\"\"Fetch YouTube transcript using youtube_transcript_api and convert to Transcription model.\n\n    Args:\n        video_url_or_id: YouTube video url or ID (11 characters)\n\n    Returns:\n        Transcription: A Transcription pydantic model with segments having start/end times\n\n    Example:\n        &gt;&gt;&gt; transcription = await fetch_youtube_transcript_as_transcription(\"dQw4w9WgXcQ\")\n        &gt;&gt;&gt; isinstance(transcription, Transcription)\n        True\n        &gt;&gt;&gt; len(transcription.segments) &gt; 0\n        True\n    \"\"\"\n    video_id_match = re.search(r\"(?:v=|/)([a-zA-Z0-9_-]{11})\", video_url_or_id)\n    video_id = video_id_match.group(1) if video_id_match else video_url_or_id\n\n    # Run the synchronous API call in an executor to make it async\n    loop = asyncio.get_running_loop()\n    with ProcessPoolExecutor() as executor:\n        api = YouTubeTranscriptApi()\n        transcript = await loop.run_in_executor(\n            executor, functools.partial(api.fetch, video_id)\n        )\n\n    formatter = TranscriptionFormatter()\n    return formatter.format_transcript(transcript)\n</code></pre>"},{"location":"reference/#podflix.utils.youtube.get_youtube_info","title":"get_youtube_info","text":"<pre><code>get_youtube_info(url, ydl_opts=None)\n</code></pre> <p>Get YouTube video information.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The YouTube video URL to get information from.</p> required <code>ydl_opts</code> <code>dict | None</code> <p>Optional additional options for yt-dlp.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing video information.</p> Source code in <code>src/podflix/utils/youtube.py</code> <pre><code>def get_youtube_info(url: str, ydl_opts: dict | None = None) -&gt; dict:\n    \"\"\"Get YouTube video information.\n\n    Args:\n        url: The YouTube video URL to get information from.\n        ydl_opts: Optional additional options for yt-dlp.\n\n    Returns:\n        A dictionary containing video information.\n    \"\"\"\n    if ydl_opts is None:\n        ydl_opts = {}\n\n    with YoutubeDL(ydl_opts) as ydl:\n        return ydl.sanitize_info(ydl.extract_info(url, download=False))\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This part of the project documentation focuses on a learning-oriented approach. You'll learn how to get started with the code in this project.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Help newcomers with getting started</li> <li>Teach readers about your library by making them     write code</li> <li>Inspire confidence through examples that work for     everyone, repeatably</li> <li>Give readers an immediate sense of achievement</li> <li>Show concrete examples, no abstractions</li> <li>Provide the minimum necessary explanation</li> <li>Avoid any distractions</li> </ul>"},{"location":"chainlit/custom_element/","title":"Custom","text":"<p>The <code>CustomElement</code> class allows you to render a custom <code>.jsx</code> snippet. The <code>.jsx</code> file should be placed in <code>public/elements/ELEMENT_NAME.jsx</code>.</p>"},{"location":"chainlit/custom_element/#attributes","title":"Attributes","text":"<p>   The name of the custom Element. It should match the name of your JSX file (without the <code>.jsx</code> extension). </p> <p>   The props to pass to the JSX. </p> <p>   Determines how the text element should be displayed in the UI. Choices are   \"side\", \"inline\", or \"page\". </p>"},{"location":"chainlit/custom_element/#how-to-write-the-jsx-file","title":"How to Write the JSX file","text":"<p>If you are not familiar with UI development, you can pass these instructions to an LLM to ask it to generate the <code>.jsx</code> for you!</p> <p>To implement the <code>jsx</code> file for your Chainlit custom element, follow these instructions.</p>"},{"location":"chainlit/custom_element/#component-definition","title":"Component definition","text":"<p>Only write JSX code, no TSX. Each <code>.jsx</code> file should export default one component like:</p> <pre><code>export default function MyComponent() {\n    return &lt;div&gt;Hello World&lt;/div&gt;\n}\n</code></pre> <p>The component <code>props</code> are globally injected (not as a function argument). NEVER pass them as function argument.</p>"},{"location":"chainlit/custom_element/#use-tailwind-for-styling","title":"Use Tailwind for Styling","text":"<p>Under the hood, the code will be rendered in a shadcn + tailwind environment. The theme is relying on CSS variables.</p> <p>Here is an example rendering a <code>div</code> with a primary color background and round border:</p> <pre><code>export default function TailwindExample() {\n    return &lt;div className=\"bg-primary rounded-md h-4 w-full\" /&gt;\n}\n</code></pre>"},{"location":"chainlit/custom_element/#only-use-allowed-imports","title":"Only Use Allowed Imports","text":"<p>Only use available packages for imports. Here is the full list:</p> <ul> <li><code>react</code></li> <li><code>sonner</code></li> <li><code>zod</code></li> <li><code>recoil</code></li> <li><code>react-hook-form</code></li> <li><code>lucide-react</code></li> <li><code>@/components/ui/accordion</code></li> <li><code>@/components/ui/aspect-ratio</code></li> <li><code>@/components/ui/avatar</code></li> <li><code>@/components/ui/badge</code></li> <li><code>@/components/ui/button</code></li> <li><code>@/components/ui/card</code></li> <li><code>@/components/ui/carousel</code></li> <li><code>@/components/ui/checkbox</code></li> <li><code>@/components/ui/command</code></li> <li><code>@/components/ui/dialog</code></li> <li><code>@/components/ui/dropdown-menu</code></li> <li><code>@/components/ui/form</code></li> <li><code>@/components/ui/hover-card</code></li> <li><code>@/components/ui/input</code></li> <li><code>@/components/ui/label</code></li> <li><code>@/components/ui/pagination</code></li> <li><code>@/components/ui/popover</code></li> <li><code>@/components/ui/progress</code></li> <li><code>@/components/ui/scroll-area</code></li> <li><code>@/components/ui/separator</code></li> <li><code>@/components/ui/select</code></li> <li><code>@/components/ui/sheet</code></li> <li><code>@/components/ui/skeleton</code></li> <li><code>@/components/ui/switch</code></li> <li><code>@/components/ui/table</code></li> <li><code>@/components/ui/textarea</code></li> <li><code>@/components/ui/tooltip</code></li> </ul> <p>The <code>@/components/ui</code> imports are from Shadcn.</p>"},{"location":"chainlit/custom_element/#available-apis","title":"Available APIs","text":"<p>Chainlit exposes the following APIs globally to make the custom element interactive.</p> <pre><code>interface APIs {\n    // Update the element props. This will re-render the element.\n    updateElement: (nextProps: Record&lt;string, any&gt;) =&gt; Promise&lt;{success: boolean}&gt;;\n    // Delete the element entirely.\n    deleteElement: () =&gt; Promise&lt;{success: boolean}&gt;;\n    // Call an action defined in the Chainlit app\n    callAction: (action: {name: string, payload: Record&lt;string, unknown&gt;}) =&gt;Promise&lt;{success: boolean}&gt;;\n    // Send a user message\n    sendUserMessage: (message: string) =&gt; void;\n}\n</code></pre>"},{"location":"chainlit/custom_element/#example-of-a-counter-element","title":"Example of a Counter Element","text":"<pre><code>import { Button } from \"@/components/ui/button\"\nimport { X, Plus } from 'lucide-react';\n\nexport default function Counter() {\n    return (\n        &lt;div id=\"custom-counter\" className=\"mt-4 flex flex-col gap-2\"&gt;\n                &lt;div&gt;Count: {props.count}&lt;/div&gt;\n                &lt;Button id=\"increment\" onClick={() =&gt; updateElement(Object.assign(props, {count: props.count + 1}))}&gt;&lt;Plus /&gt; Increment&lt;/Button&gt;\n                &lt;Button id=\"remove\" onClick={deleteElement}&gt;&lt;X /&gt; Remove&lt;/Button&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre>"},{"location":"chainlit/custom_element/#full-example","title":"Full Example","text":"<p>Let's build a custom element to render the status of a Linear ticket.</p> <p>First, we write a small Chainlit application faking fetching data from linear:</p> <p>```python app.py import chainlit as cl</p> <p>async def get_ticket():     \"\"\"Pretending to fetch data from linear\"\"\"     return {         \"title\": \"Fix Authentication Bug\",         \"status\": \"in-progress\",         \"assignee\": \"Sarah Chen\",         \"deadline\": \"2025-01-15\",         \"tags\": [\"security\", \"high-priority\", \"backend\"]     }</p> <p>@cl.on_message async def on_message(msg: cl.Message):     # Let's pretend the user is asking about a linear ticket.     # Usually an LLM with tool calling would be used to decide to render the component or not.</p> <pre><code>props = await get_ticket()\n\nticket_element = cl.CustomElement(name=\"LinearTicket\", props=props)\n# Store the element if we want to update it server side at a later stage.\ncl.user_session.set(\"ticket_el\", ticket_element)\n\nawait cl.Message(content=\"Here is the ticket information!\", elements=[ticket_element]).send()\n</code></pre> <pre><code>\nSecond we implement the custom element we reference in the Python code:\n\n```jsx public/elements/LinearTicket.jsx\nimport { Card, CardHeader, CardTitle, CardContent } from \"@/components/ui/card\"\nimport { Badge } from \"@/components/ui/badge\"\nimport { Progress } from \"@/components/ui/progress\"\nimport { Clock, User, Tag } from \"lucide-react\"\n\nexport default function TicketStatusCard() {\n  const getProgressValue = (status) =&gt; {\n    const progress = {\n      'open': 25,\n      'in-progress': 50,\n      'resolved': 75,\n      'closed': 100\n    }\n    return progress[status] || 0\n  }\n\n  return (\n    &lt;Card className=\"w-full max-w-md\"&gt;\n      &lt;CardHeader className=\"pb-2\"&gt;\n        &lt;div className=\"flex justify-between items-center\"&gt;\n          &lt;CardTitle className=\"text-lg font-medium\"&gt;\n            {props.title || 'Untitled Ticket'}\n          &lt;/CardTitle&gt;\n          &lt;Badge\n            variant=\"outline\"\n          &gt;\n            {props.status || 'Unknown'}\n          &lt;/Badge&gt;\n        &lt;/div&gt;\n      &lt;/CardHeader&gt;\n      &lt;CardContent&gt;\n        &lt;div className=\"space-y-4\"&gt;\n          &lt;Progress value={getProgressValue(props.status)} className=\"h-2\" /&gt;\n\n          &lt;div className=\"grid grid-cols-2 gap-4 text-sm\"&gt;\n            &lt;div className=\"flex items-center gap-2\"&gt;\n              &lt;User className=\"h-4 w-4 opacity-70\" /&gt;\n              &lt;span&gt;{props.assignee || 'Unassigned'}&lt;/span&gt;\n            &lt;/div&gt;\n            &lt;div className=\"flex items-center gap-2\"&gt;\n              &lt;Clock className=\"h-4 w-4 opacity-70\" /&gt;\n              &lt;span&gt;{props.deadline || 'No deadline'}&lt;/span&gt;\n            &lt;/div&gt;\n            &lt;div className=\"flex items-center gap-2 col-span-2\"&gt;\n              &lt;Tag className=\"h-4 w-4 opacity-70\" /&gt;\n              &lt;span&gt;{props.tags?.join(', ') || 'No tags'}&lt;/span&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/CardContent&gt;\n    &lt;/Card&gt;\n  )\n}\n</code></pre> <p>Finally, we start the application with <code>chainlit run app.py</code> and send a first message in the UI.</p> <p> </p>"},{"location":"chainlit/custom_element/#advanced","title":"Advanced","text":""},{"location":"chainlit/custom_element/#update-props-from-python","title":"Update Props from Python","text":"<p>To update a custom element props from the python code, you can store the element instance in the user session and call <code>.update()</code> on it.</p> <pre><code>import chainlit as cl\n\n@cl.on_chat_start\nasync def start():\n    element = cl.CustomElement(name=\"Foo\", props={\"foo\": \"bar\"})\n    cl.user_session.set(\"element\", element)\n\n@cl.on_message\nasync def on_message():\n    element = cl.user_session.get(\"element\")\n    element.props[\"foo\"] = \"baz\"\n    await element.update()\n</code></pre>"},{"location":"chainlit/custom_element/#call-a-function-from-python","title":"Call a Function from Python","text":"<p>If you need to call a function directly from the python code, you can use <code>cl.CopilotFunction</code>.</p> <p>```python call_func.py import chainlit as cl</p> <p>@cl.on_chat_start async def start():     element = cl.CustomElement(name=\"CallFn\")     await cl.Message(content=\"Hello\", elements=[element]).send()</p> <p>@cl.on_message async def on_msg(msg: cl.Message):     fn = cl.CopilotFunction(name=\"test\", args={\"content\": msg.content})     res = await fn.acall()</p> <pre><code>\n```jsx CallFn.jsx\nimport { useEffect } from 'react';\nimport { useRecoilValue } from 'recoil';\nimport { callFnState } from '@chainlit/react-client';\n\nexport default function CallFnExample() {\n    const callFn = useRecoilValue(callFnState);\n\n    useEffect(() =&gt; {\n        if (callFn?.name === \"test\") {\n          // Replace the console log with your actual function\n          console.log(\"Function called with\", callFn.args.content)\n          callFn.callback()\n        }\n      }, [callFn]);\n\n      return null\n}\n</code></pre>"}]}